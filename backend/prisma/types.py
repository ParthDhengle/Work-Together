# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _ProjectStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.ProjectStatus']]


class _ProjectStatusListFilterHasInput(TypedDict):
    has: 'enums.ProjectStatus'


class _ProjectStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.ProjectStatus']


class _ProjectStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.ProjectStatus']


class _ProjectStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


ProjectStatusListFilter = Union[
    _ProjectStatusListFilterHasInput,
    _ProjectStatusListFilterEqualsInput,
    _ProjectStatusListFilterHasSomeInput,
    _ProjectStatusListFilterIsEmptyInput,
    _ProjectStatusListFilterHasEveryInput,
]


class _ProjectStatusListUpdateSet(TypedDict):
    set: List['enums.ProjectStatus']


class _ProjectStatusListUpdatePush(TypedDict):
    push: List['enums.ProjectStatus']


ProjectStatusListUpdate = Union[
    List['enums.ProjectStatus'],
    _ProjectStatusListUpdateSet,
    _ProjectStatusListUpdatePush,
]

class _TaskStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.TaskStatus']]


class _TaskStatusListFilterHasInput(TypedDict):
    has: 'enums.TaskStatus'


class _TaskStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.TaskStatus']


class _TaskStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.TaskStatus']


class _TaskStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


TaskStatusListFilter = Union[
    _TaskStatusListFilterHasInput,
    _TaskStatusListFilterEqualsInput,
    _TaskStatusListFilterHasSomeInput,
    _TaskStatusListFilterIsEmptyInput,
    _TaskStatusListFilterHasEveryInput,
]


class _TaskStatusListUpdateSet(TypedDict):
    set: List['enums.TaskStatus']


class _TaskStatusListUpdatePush(TypedDict):
    push: List['enums.TaskStatus']


TaskStatusListUpdate = Union[
    List['enums.TaskStatus'],
    _TaskStatusListUpdateSet,
    _TaskStatusListUpdatePush,
]

class _WorkerStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.WorkerStatus']]


class _WorkerStatusListFilterHasInput(TypedDict):
    has: 'enums.WorkerStatus'


class _WorkerStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.WorkerStatus']


class _WorkerStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.WorkerStatus']


class _WorkerStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


WorkerStatusListFilter = Union[
    _WorkerStatusListFilterHasInput,
    _WorkerStatusListFilterEqualsInput,
    _WorkerStatusListFilterHasSomeInput,
    _WorkerStatusListFilterIsEmptyInput,
    _WorkerStatusListFilterHasEveryInput,
]


class _WorkerStatusListUpdateSet(TypedDict):
    set: List['enums.WorkerStatus']


class _WorkerStatusListUpdatePush(TypedDict):
    push: List['enums.WorkerStatus']


WorkerStatusListUpdate = Union[
    List['enums.WorkerStatus'],
    _WorkerStatusListUpdateSet,
    _WorkerStatusListUpdatePush,
]

class _PriorityListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.Priority']]


class _PriorityListFilterHasInput(TypedDict):
    has: 'enums.Priority'


class _PriorityListFilterHasEveryInput(TypedDict):
    has_every: List['enums.Priority']


class _PriorityListFilterHasSomeInput(TypedDict):
    has_some: List['enums.Priority']


class _PriorityListFilterIsEmptyInput(TypedDict):
    is_empty: bool


PriorityListFilter = Union[
    _PriorityListFilterHasInput,
    _PriorityListFilterEqualsInput,
    _PriorityListFilterHasSomeInput,
    _PriorityListFilterIsEmptyInput,
    _PriorityListFilterHasEveryInput,
]


class _PriorityListUpdateSet(TypedDict):
    set: List['enums.Priority']


class _PriorityListUpdatePush(TypedDict):
    push: List['enums.Priority']


PriorityListUpdate = Union[
    List['enums.Priority'],
    _PriorityListUpdateSet,
    _PriorityListUpdatePush,
]

class _TeamListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.Team']]


class _TeamListFilterHasInput(TypedDict):
    has: 'enums.Team'


class _TeamListFilterHasEveryInput(TypedDict):
    has_every: List['enums.Team']


class _TeamListFilterHasSomeInput(TypedDict):
    has_some: List['enums.Team']


class _TeamListFilterIsEmptyInput(TypedDict):
    is_empty: bool


TeamListFilter = Union[
    _TeamListFilterHasInput,
    _TeamListFilterEqualsInput,
    _TeamListFilterHasSomeInput,
    _TeamListFilterIsEmptyInput,
    _TeamListFilterHasEveryInput,
]


class _TeamListUpdateSet(TypedDict):
    set: List['enums.Team']


class _TeamListUpdatePush(TypedDict):
    push: List['enums.Team']


TeamListUpdate = Union[
    List['enums.Team'],
    _TeamListUpdateSet,
    _TeamListUpdatePush,
]


# Project types

class ProjectOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Project create method"""
    id: _str
    description: Optional[_str]
    status: 'enums.ProjectStatus'
    tasks: 'TaskCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProjectCreateInput(ProjectOptionalCreateInput):
    """Required arguments to the Project create method"""
    name: _str
    startDate: datetime.datetime
    endDate: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ProjectOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Project create method, without relations"""
    id: _str
    description: Optional[_str]
    status: 'enums.ProjectStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProjectCreateWithoutRelationsInput(ProjectOptionalCreateWithoutRelationsInput):
    """Required arguments to the Project create method, without relations"""
    name: _str
    startDate: datetime.datetime
    endDate: datetime.datetime

class ProjectConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ProjectCreateWithoutRelationsInput'
    where: 'ProjectWhereUniqueInput'

class ProjectCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ProjectCreateWithoutRelationsInput'
    connect: 'ProjectWhereUniqueInput'
    connect_or_create: 'ProjectConnectOrCreateWithoutRelationsInput'


class ProjectCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ProjectCreateWithoutRelationsInput', List['ProjectCreateWithoutRelationsInput']]
    connect: Union['ProjectWhereUniqueInput', List['ProjectWhereUniqueInput']]
    connect_or_create: Union['ProjectConnectOrCreateWithoutRelationsInput', List['ProjectConnectOrCreateWithoutRelationsInput']]

_ProjectWhereUnique_id_Input = TypedDict(
    '_ProjectWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ProjectWhereUniqueInput = _ProjectWhereUnique_id_Input


class ProjectUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    description: Optional[_str]
    startDate: datetime.datetime
    endDate: datetime.datetime
    status: 'enums.ProjectStatus'
    tasks: 'TaskUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProjectUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    description: Optional[_str]
    startDate: datetime.datetime
    endDate: datetime.datetime
    status: 'enums.ProjectStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProjectUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ProjectCreateWithoutRelationsInput']
    connect: List['ProjectWhereUniqueInput']
    connect_or_create: List['ProjectConnectOrCreateWithoutRelationsInput']
    set: List['ProjectWhereUniqueInput']
    disconnect: List['ProjectWhereUniqueInput']
    delete: List['ProjectWhereUniqueInput']

    # TODO
    # update: List['ProjectUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ProjectUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ProjectScalarWhereInput']
    # upsert: List['ProjectUpserteWithWhereUniqueWithoutRelationsInput']


class ProjectUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ProjectCreateWithoutRelationsInput'
    connect: 'ProjectWhereUniqueInput'
    connect_or_create: 'ProjectConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ProjectUpdateInput'
    # upsert: 'ProjectUpsertWithoutRelationsInput'


class ProjectUpsertInput(TypedDict):
    create: 'ProjectCreateInput'
    update: 'ProjectUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Project_id_OrderByInput = TypedDict(
    '_Project_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Project_name_OrderByInput = TypedDict(
    '_Project_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Project_description_OrderByInput = TypedDict(
    '_Project_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Project_startDate_OrderByInput = TypedDict(
    '_Project_startDate_OrderByInput',
    {
        'startDate': 'SortOrder',
    },
    total=True
)

_Project_endDate_OrderByInput = TypedDict(
    '_Project_endDate_OrderByInput',
    {
        'endDate': 'SortOrder',
    },
    total=True
)

_Project_status_OrderByInput = TypedDict(
    '_Project_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Project_createdAt_OrderByInput = TypedDict(
    '_Project_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Project_updatedAt_OrderByInput = TypedDict(
    '_Project_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Project_RelevanceInner = TypedDict(
    '_Project_RelevanceInner',
    {
        'fields': 'List[ProjectScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Project_RelevanceOrderByInput = TypedDict(
    '_Project_RelevanceOrderByInput',
    {
        '_relevance': '_Project_RelevanceInner',
    },
    total=True
)

ProjectOrderByInput = Union[
    '_Project_id_OrderByInput',
    '_Project_name_OrderByInput',
    '_Project_description_OrderByInput',
    '_Project_startDate_OrderByInput',
    '_Project_endDate_OrderByInput',
    '_Project_status_OrderByInput',
    '_Project_createdAt_OrderByInput',
    '_Project_updatedAt_OrderByInput',
    '_Project_RelevanceOrderByInput',
]



# recursive Project types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ProjectRelationFilter = TypedDict(
    'ProjectRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ProjectListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ProjectInclude(TypedDict, total=False):
    """Project relational arguments"""
    tasks: Union[bool, 'FindManyTaskArgsFromProject']


    

class ProjectIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    tasks: Union[bool, 'FindManyTaskArgsFromProjectRecursive1']


class ProjectIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    tasks: Union[bool, 'FindManyTaskArgsFromProjectRecursive2']


class ProjectIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    tasks: Union[bool, 'FindManyTaskArgsFromProjectRecursive3']


class ProjectIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    tasks: Union[bool, 'FindManyTaskArgsFromProjectRecursive4']


class ProjectIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class ProjectArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyProjectArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class TaskIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive1']
    assignedWorker: Union[bool, 'WorkerArgsFromProjectRecursive1']
    assignments: Union[bool, 'FindManyAssignmentArgsFromProjectRecursive1']


class TaskIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive2']
    assignedWorker: Union[bool, 'WorkerArgsFromProjectRecursive2']
    assignments: Union[bool, 'FindManyAssignmentArgsFromProjectRecursive2']


class TaskIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive3']
    assignedWorker: Union[bool, 'WorkerArgsFromProjectRecursive3']
    assignments: Union[bool, 'FindManyAssignmentArgsFromProjectRecursive3']


class TaskIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive4']
    assignedWorker: Union[bool, 'WorkerArgsFromProjectRecursive4']
    assignments: Union[bool, 'FindManyAssignmentArgsFromProjectRecursive4']


class TaskIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class TaskArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'TaskIncludeFromTaskRecursive1'


class TaskArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'TaskIncludeFromTaskRecursive2'


class TaskArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'TaskIncludeFromTaskRecursive3'


class TaskArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'TaskIncludeFromTaskRecursive4'


class TaskArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyTaskArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive1'


class FindManyTaskArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive2'


class FindManyTaskArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive3'


class FindManyTaskArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive4'


class FindManyTaskArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    
    

class WorkerIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    tasks: Union[bool, 'FindManyTaskArgsFromProjectRecursive1']
    assignments: Union[bool, 'FindManyAssignmentArgsFromProjectRecursive1']


class WorkerIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    tasks: Union[bool, 'FindManyTaskArgsFromProjectRecursive2']
    assignments: Union[bool, 'FindManyAssignmentArgsFromProjectRecursive2']


class WorkerIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    tasks: Union[bool, 'FindManyTaskArgsFromProjectRecursive3']
    assignments: Union[bool, 'FindManyAssignmentArgsFromProjectRecursive3']


class WorkerIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    tasks: Union[bool, 'FindManyTaskArgsFromProjectRecursive4']
    assignments: Union[bool, 'FindManyAssignmentArgsFromProjectRecursive4']


class WorkerIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class WorkerArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'WorkerIncludeFromWorkerRecursive1'


class WorkerArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'WorkerIncludeFromWorkerRecursive2'


class WorkerArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'WorkerIncludeFromWorkerRecursive3'


class WorkerArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'WorkerIncludeFromWorkerRecursive4'


class WorkerArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyWorkerArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive1'


class FindManyWorkerArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive2'


class FindManyWorkerArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive3'


class FindManyWorkerArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive4'


class FindManyWorkerArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    
    

class AssignmentIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    task: Union[bool, 'TaskArgsFromProjectRecursive1']
    worker: Union[bool, 'WorkerArgsFromProjectRecursive1']


class AssignmentIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    task: Union[bool, 'TaskArgsFromProjectRecursive2']
    worker: Union[bool, 'WorkerArgsFromProjectRecursive2']


class AssignmentIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    task: Union[bool, 'TaskArgsFromProjectRecursive3']
    worker: Union[bool, 'WorkerArgsFromProjectRecursive3']


class AssignmentIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    task: Union[bool, 'TaskArgsFromProjectRecursive4']
    worker: Union[bool, 'WorkerArgsFromProjectRecursive4']


class AssignmentIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class AssignmentArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'AssignmentIncludeFromAssignmentRecursive1'


class AssignmentArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'AssignmentIncludeFromAssignmentRecursive2'


class AssignmentArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'AssignmentIncludeFromAssignmentRecursive3'


class AssignmentArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'AssignmentIncludeFromAssignmentRecursive4'


class AssignmentArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyAssignmentArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive1'


class FindManyAssignmentArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive2'


class FindManyAssignmentArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive3'


class FindManyAssignmentArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive4'


class FindManyAssignmentArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    
    

class LogIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""


class LogIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""


class LogIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""


class LogIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""


class LogIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class LogArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'LogIncludeFromLogRecursive1'


class LogArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'LogIncludeFromLogRecursive2'


class LogArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'LogIncludeFromLogRecursive3'


class LogArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'LogIncludeFromLogRecursive4'


class LogArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyLogArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive1'


class FindManyLogArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive2'


class FindManyLogArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive3'


class FindManyLogArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive4'


class FindManyLogArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    


FindManyProjectArgs = FindManyProjectArgsFromProject
FindFirstProjectArgs = FindManyProjectArgsFromProject


    

class ProjectWhereInput(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.ProjectStatus'
    tasks: 'TaskListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive1', List['ProjectWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive1']
    OR: List['ProjectWhereInputRecursive1']
    NOT: List['ProjectWhereInputRecursive1']


class ProjectWhereInputRecursive1(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.ProjectStatus'
    tasks: 'TaskListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive2', List['ProjectWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive2']
    OR: List['ProjectWhereInputRecursive2']
    NOT: List['ProjectWhereInputRecursive2']


class ProjectWhereInputRecursive2(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.ProjectStatus'
    tasks: 'TaskListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive3', List['ProjectWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive3']
    OR: List['ProjectWhereInputRecursive3']
    NOT: List['ProjectWhereInputRecursive3']


class ProjectWhereInputRecursive3(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.ProjectStatus'
    tasks: 'TaskListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive4', List['ProjectWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive4']
    OR: List['ProjectWhereInputRecursive4']
    NOT: List['ProjectWhereInputRecursive4']


class ProjectWhereInputRecursive4(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.ProjectStatus'
    tasks: 'TaskListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Project types


    

class ProjectScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.ProjectStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive1']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive1']


class ProjectScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.ProjectStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive2']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive2']


class ProjectScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.ProjectStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive3']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive3']


class ProjectScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.ProjectStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive4']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive4']


class ProjectScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.ProjectStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class ProjectGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    description: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    status: 'enums.ProjectStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'ProjectSumAggregateOutput'
    _avg: 'ProjectAvgAggregateOutput'
    _min: 'ProjectMinAggregateOutput'
    _max: 'ProjectMaxAggregateOutput'
    _count: 'ProjectCountAggregateOutput'


class ProjectAvgAggregateOutput(TypedDict, total=False):
    """Project output for aggregating averages"""


class ProjectSumAggregateOutput(TypedDict, total=False):
    """Project output for aggregating sums"""


class ProjectScalarAggregateOutput(TypedDict, total=False):
    """Project output including scalar fields"""
    id: _str
    name: _str
    description: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    status: 'enums.ProjectStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


ProjectMinAggregateOutput = ProjectScalarAggregateOutput
ProjectMaxAggregateOutput = ProjectScalarAggregateOutput


class ProjectMaxAggregateInput(TypedDict, total=False):
    """Project input for aggregating by max"""
    id: bool
    name: bool
    description: bool
    startDate: bool
    endDate: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class ProjectMinAggregateInput(TypedDict, total=False):
    """Project input for aggregating by min"""
    id: bool
    name: bool
    description: bool
    startDate: bool
    endDate: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class ProjectNumberAggregateInput(TypedDict, total=False):
    """Project input for aggregating numbers"""


ProjectAvgAggregateInput = ProjectNumberAggregateInput
ProjectSumAggregateInput = ProjectNumberAggregateInput


ProjectCountAggregateInput = TypedDict(
    'ProjectCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'description': bool,
        'startDate': bool,
        'endDate': bool,
        'status': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

ProjectCountAggregateOutput = TypedDict(
    'ProjectCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'description': int,
        'startDate': int,
        'endDate': int,
        'status': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


ProjectKeys = Literal[
    'id',
    'name',
    'description',
    'startDate',
    'endDate',
    'status',
    'tasks',
    'createdAt',
    'updatedAt',
]
ProjectScalarFieldKeys = Literal[
    'id',
    'name',
    'description',
    'startDate',
    'endDate',
    'status',
    'createdAt',
    'updatedAt',
]
ProjectScalarFieldKeysT = TypeVar('ProjectScalarFieldKeysT', bound=ProjectScalarFieldKeys)

ProjectRelationalFieldKeys = Literal[
        'tasks',
    ]

# Task types

class TaskOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Task create method"""
    id: _str
    projectId: _str
    project: 'ProjectCreateNestedWithoutRelationsInput'
    description: Optional[_str]
    skillRequirement: Optional[_str]
    priority: 'enums.Priority'
    status: 'enums.TaskStatus'
    assignedWorkerId: Optional[_str]
    assignedWorker: 'WorkerCreateNestedWithoutRelationsInput'
    assignments: 'AssignmentCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TaskCreateInput(TaskOptionalCreateInput):
    """Required arguments to the Task create method"""
    name: _str
    estimatedDuration: _int
    deadline: datetime.datetime
    assignedTeam: 'enums.Team'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TaskOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Task create method, without relations"""
    id: _str
    projectId: _str
    description: Optional[_str]
    skillRequirement: Optional[_str]
    priority: 'enums.Priority'
    status: 'enums.TaskStatus'
    assignedWorkerId: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TaskCreateWithoutRelationsInput(TaskOptionalCreateWithoutRelationsInput):
    """Required arguments to the Task create method, without relations"""
    name: _str
    estimatedDuration: _int
    deadline: datetime.datetime
    assignedTeam: 'enums.Team'

class TaskConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TaskCreateWithoutRelationsInput'
    where: 'TaskWhereUniqueInput'

class TaskCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TaskCreateWithoutRelationsInput'
    connect: 'TaskWhereUniqueInput'
    connect_or_create: 'TaskConnectOrCreateWithoutRelationsInput'


class TaskCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TaskCreateWithoutRelationsInput', List['TaskCreateWithoutRelationsInput']]
    connect: Union['TaskWhereUniqueInput', List['TaskWhereUniqueInput']]
    connect_or_create: Union['TaskConnectOrCreateWithoutRelationsInput', List['TaskConnectOrCreateWithoutRelationsInput']]

_TaskWhereUnique_id_Input = TypedDict(
    '_TaskWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

TaskWhereUniqueInput = _TaskWhereUnique_id_Input


class TaskUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    project: 'ProjectUpdateOneWithoutRelationsInput'
    name: _str
    description: Optional[_str]
    skillRequirement: Optional[_str]
    priority: 'enums.Priority'
    estimatedDuration: Union[AtomicIntInput, _int]
    deadline: datetime.datetime
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorker: 'WorkerUpdateOneWithoutRelationsInput'
    assignments: 'AssignmentUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TaskUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    description: Optional[_str]
    skillRequirement: Optional[_str]
    priority: 'enums.Priority'
    estimatedDuration: Union[AtomicIntInput, _int]
    deadline: datetime.datetime
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TaskUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TaskCreateWithoutRelationsInput']
    connect: List['TaskWhereUniqueInput']
    connect_or_create: List['TaskConnectOrCreateWithoutRelationsInput']
    set: List['TaskWhereUniqueInput']
    disconnect: List['TaskWhereUniqueInput']
    delete: List['TaskWhereUniqueInput']

    # TODO
    # update: List['TaskUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TaskUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TaskScalarWhereInput']
    # upsert: List['TaskUpserteWithWhereUniqueWithoutRelationsInput']


class TaskUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TaskCreateWithoutRelationsInput'
    connect: 'TaskWhereUniqueInput'
    connect_or_create: 'TaskConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TaskUpdateInput'
    # upsert: 'TaskUpsertWithoutRelationsInput'


class TaskUpsertInput(TypedDict):
    create: 'TaskCreateInput'
    update: 'TaskUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Task_id_OrderByInput = TypedDict(
    '_Task_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Task_projectId_OrderByInput = TypedDict(
    '_Task_projectId_OrderByInput',
    {
        'projectId': 'SortOrder',
    },
    total=True
)

_Task_name_OrderByInput = TypedDict(
    '_Task_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Task_description_OrderByInput = TypedDict(
    '_Task_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Task_skillRequirement_OrderByInput = TypedDict(
    '_Task_skillRequirement_OrderByInput',
    {
        'skillRequirement': 'SortOrder',
    },
    total=True
)

_Task_priority_OrderByInput = TypedDict(
    '_Task_priority_OrderByInput',
    {
        'priority': 'SortOrder',
    },
    total=True
)

_Task_estimatedDuration_OrderByInput = TypedDict(
    '_Task_estimatedDuration_OrderByInput',
    {
        'estimatedDuration': 'SortOrder',
    },
    total=True
)

_Task_deadline_OrderByInput = TypedDict(
    '_Task_deadline_OrderByInput',
    {
        'deadline': 'SortOrder',
    },
    total=True
)

_Task_assignedTeam_OrderByInput = TypedDict(
    '_Task_assignedTeam_OrderByInput',
    {
        'assignedTeam': 'SortOrder',
    },
    total=True
)

_Task_status_OrderByInput = TypedDict(
    '_Task_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Task_assignedWorkerId_OrderByInput = TypedDict(
    '_Task_assignedWorkerId_OrderByInput',
    {
        'assignedWorkerId': 'SortOrder',
    },
    total=True
)

_Task_createdAt_OrderByInput = TypedDict(
    '_Task_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Task_updatedAt_OrderByInput = TypedDict(
    '_Task_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Task_RelevanceInner = TypedDict(
    '_Task_RelevanceInner',
    {
        'fields': 'List[TaskScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Task_RelevanceOrderByInput = TypedDict(
    '_Task_RelevanceOrderByInput',
    {
        '_relevance': '_Task_RelevanceInner',
    },
    total=True
)

TaskOrderByInput = Union[
    '_Task_id_OrderByInput',
    '_Task_projectId_OrderByInput',
    '_Task_name_OrderByInput',
    '_Task_description_OrderByInput',
    '_Task_skillRequirement_OrderByInput',
    '_Task_priority_OrderByInput',
    '_Task_estimatedDuration_OrderByInput',
    '_Task_deadline_OrderByInput',
    '_Task_assignedTeam_OrderByInput',
    '_Task_status_OrderByInput',
    '_Task_assignedWorkerId_OrderByInput',
    '_Task_createdAt_OrderByInput',
    '_Task_updatedAt_OrderByInput',
    '_Task_RelevanceOrderByInput',
]



# recursive Task types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TaskRelationFilter = TypedDict(
    'TaskRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TaskListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TaskInclude(TypedDict, total=False):
    """Task relational arguments"""
    project: Union[bool, 'ProjectArgsFromTask']
    assignedWorker: Union[bool, 'WorkerArgsFromTask']
    assignments: Union[bool, 'FindManyAssignmentArgsFromTask']


    

class ProjectIncludeFromTask(TypedDict, total=False):
    """Relational arguments for Task"""
    tasks: Union[bool, 'FindManyTaskArgsFromTaskRecursive1']


class ProjectIncludeFromTaskRecursive1(TypedDict, total=False):
    """Relational arguments for Task"""
    tasks: Union[bool, 'FindManyTaskArgsFromTaskRecursive2']


class ProjectIncludeFromTaskRecursive2(TypedDict, total=False):
    """Relational arguments for Task"""
    tasks: Union[bool, 'FindManyTaskArgsFromTaskRecursive3']


class ProjectIncludeFromTaskRecursive3(TypedDict, total=False):
    """Relational arguments for Task"""
    tasks: Union[bool, 'FindManyTaskArgsFromTaskRecursive4']


class ProjectIncludeFromTaskRecursive4(TypedDict, total=False):
    """Relational arguments for Task"""

    

class ProjectArgsFromTask(TypedDict, total=False):
    """Arguments for Task"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromTaskRecursive1(TypedDict, total=False):
    """Arguments for Task"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromTaskRecursive2(TypedDict, total=False):
    """Arguments for Task"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromTaskRecursive3(TypedDict, total=False):
    """Arguments for Task"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromTaskRecursive4(TypedDict, total=False):
    """Arguments for Task"""
    
    

class FindManyProjectArgsFromTask(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromTaskRecursive1(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromTaskRecursive2(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromTaskRecursive3(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromTaskRecursive4(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class TaskIncludeFromTask(TypedDict, total=False):
    """Relational arguments for Task"""
    project: Union[bool, 'ProjectArgsFromTaskRecursive1']
    assignedWorker: Union[bool, 'WorkerArgsFromTaskRecursive1']
    assignments: Union[bool, 'FindManyAssignmentArgsFromTaskRecursive1']


class TaskIncludeFromTaskRecursive1(TypedDict, total=False):
    """Relational arguments for Task"""
    project: Union[bool, 'ProjectArgsFromTaskRecursive2']
    assignedWorker: Union[bool, 'WorkerArgsFromTaskRecursive2']
    assignments: Union[bool, 'FindManyAssignmentArgsFromTaskRecursive2']


class TaskIncludeFromTaskRecursive2(TypedDict, total=False):
    """Relational arguments for Task"""
    project: Union[bool, 'ProjectArgsFromTaskRecursive3']
    assignedWorker: Union[bool, 'WorkerArgsFromTaskRecursive3']
    assignments: Union[bool, 'FindManyAssignmentArgsFromTaskRecursive3']


class TaskIncludeFromTaskRecursive3(TypedDict, total=False):
    """Relational arguments for Task"""
    project: Union[bool, 'ProjectArgsFromTaskRecursive4']
    assignedWorker: Union[bool, 'WorkerArgsFromTaskRecursive4']
    assignments: Union[bool, 'FindManyAssignmentArgsFromTaskRecursive4']


class TaskIncludeFromTaskRecursive4(TypedDict, total=False):
    """Relational arguments for Task"""

    

class TaskArgsFromTask(TypedDict, total=False):
    """Arguments for Task"""
    include: 'TaskIncludeFromTaskRecursive1'


class TaskArgsFromTaskRecursive1(TypedDict, total=False):
    """Arguments for Task"""
    include: 'TaskIncludeFromTaskRecursive2'


class TaskArgsFromTaskRecursive2(TypedDict, total=False):
    """Arguments for Task"""
    include: 'TaskIncludeFromTaskRecursive3'


class TaskArgsFromTaskRecursive3(TypedDict, total=False):
    """Arguments for Task"""
    include: 'TaskIncludeFromTaskRecursive4'


class TaskArgsFromTaskRecursive4(TypedDict, total=False):
    """Arguments for Task"""
    
    

class FindManyTaskArgsFromTask(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive1'


class FindManyTaskArgsFromTaskRecursive1(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive2'


class FindManyTaskArgsFromTaskRecursive2(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive3'


class FindManyTaskArgsFromTaskRecursive3(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive4'


class FindManyTaskArgsFromTaskRecursive4(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    
    

class WorkerIncludeFromTask(TypedDict, total=False):
    """Relational arguments for Task"""
    tasks: Union[bool, 'FindManyTaskArgsFromTaskRecursive1']
    assignments: Union[bool, 'FindManyAssignmentArgsFromTaskRecursive1']


class WorkerIncludeFromTaskRecursive1(TypedDict, total=False):
    """Relational arguments for Task"""
    tasks: Union[bool, 'FindManyTaskArgsFromTaskRecursive2']
    assignments: Union[bool, 'FindManyAssignmentArgsFromTaskRecursive2']


class WorkerIncludeFromTaskRecursive2(TypedDict, total=False):
    """Relational arguments for Task"""
    tasks: Union[bool, 'FindManyTaskArgsFromTaskRecursive3']
    assignments: Union[bool, 'FindManyAssignmentArgsFromTaskRecursive3']


class WorkerIncludeFromTaskRecursive3(TypedDict, total=False):
    """Relational arguments for Task"""
    tasks: Union[bool, 'FindManyTaskArgsFromTaskRecursive4']
    assignments: Union[bool, 'FindManyAssignmentArgsFromTaskRecursive4']


class WorkerIncludeFromTaskRecursive4(TypedDict, total=False):
    """Relational arguments for Task"""

    

class WorkerArgsFromTask(TypedDict, total=False):
    """Arguments for Task"""
    include: 'WorkerIncludeFromWorkerRecursive1'


class WorkerArgsFromTaskRecursive1(TypedDict, total=False):
    """Arguments for Task"""
    include: 'WorkerIncludeFromWorkerRecursive2'


class WorkerArgsFromTaskRecursive2(TypedDict, total=False):
    """Arguments for Task"""
    include: 'WorkerIncludeFromWorkerRecursive3'


class WorkerArgsFromTaskRecursive3(TypedDict, total=False):
    """Arguments for Task"""
    include: 'WorkerIncludeFromWorkerRecursive4'


class WorkerArgsFromTaskRecursive4(TypedDict, total=False):
    """Arguments for Task"""
    
    

class FindManyWorkerArgsFromTask(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive1'


class FindManyWorkerArgsFromTaskRecursive1(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive2'


class FindManyWorkerArgsFromTaskRecursive2(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive3'


class FindManyWorkerArgsFromTaskRecursive3(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive4'


class FindManyWorkerArgsFromTaskRecursive4(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    
    

class AssignmentIncludeFromTask(TypedDict, total=False):
    """Relational arguments for Task"""
    task: Union[bool, 'TaskArgsFromTaskRecursive1']
    worker: Union[bool, 'WorkerArgsFromTaskRecursive1']


class AssignmentIncludeFromTaskRecursive1(TypedDict, total=False):
    """Relational arguments for Task"""
    task: Union[bool, 'TaskArgsFromTaskRecursive2']
    worker: Union[bool, 'WorkerArgsFromTaskRecursive2']


class AssignmentIncludeFromTaskRecursive2(TypedDict, total=False):
    """Relational arguments for Task"""
    task: Union[bool, 'TaskArgsFromTaskRecursive3']
    worker: Union[bool, 'WorkerArgsFromTaskRecursive3']


class AssignmentIncludeFromTaskRecursive3(TypedDict, total=False):
    """Relational arguments for Task"""
    task: Union[bool, 'TaskArgsFromTaskRecursive4']
    worker: Union[bool, 'WorkerArgsFromTaskRecursive4']


class AssignmentIncludeFromTaskRecursive4(TypedDict, total=False):
    """Relational arguments for Task"""

    

class AssignmentArgsFromTask(TypedDict, total=False):
    """Arguments for Task"""
    include: 'AssignmentIncludeFromAssignmentRecursive1'


class AssignmentArgsFromTaskRecursive1(TypedDict, total=False):
    """Arguments for Task"""
    include: 'AssignmentIncludeFromAssignmentRecursive2'


class AssignmentArgsFromTaskRecursive2(TypedDict, total=False):
    """Arguments for Task"""
    include: 'AssignmentIncludeFromAssignmentRecursive3'


class AssignmentArgsFromTaskRecursive3(TypedDict, total=False):
    """Arguments for Task"""
    include: 'AssignmentIncludeFromAssignmentRecursive4'


class AssignmentArgsFromTaskRecursive4(TypedDict, total=False):
    """Arguments for Task"""
    
    

class FindManyAssignmentArgsFromTask(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive1'


class FindManyAssignmentArgsFromTaskRecursive1(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive2'


class FindManyAssignmentArgsFromTaskRecursive2(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive3'


class FindManyAssignmentArgsFromTaskRecursive3(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive4'


class FindManyAssignmentArgsFromTaskRecursive4(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    
    

class LogIncludeFromTask(TypedDict, total=False):
    """Relational arguments for Task"""


class LogIncludeFromTaskRecursive1(TypedDict, total=False):
    """Relational arguments for Task"""


class LogIncludeFromTaskRecursive2(TypedDict, total=False):
    """Relational arguments for Task"""


class LogIncludeFromTaskRecursive3(TypedDict, total=False):
    """Relational arguments for Task"""


class LogIncludeFromTaskRecursive4(TypedDict, total=False):
    """Relational arguments for Task"""

    

class LogArgsFromTask(TypedDict, total=False):
    """Arguments for Task"""
    include: 'LogIncludeFromLogRecursive1'


class LogArgsFromTaskRecursive1(TypedDict, total=False):
    """Arguments for Task"""
    include: 'LogIncludeFromLogRecursive2'


class LogArgsFromTaskRecursive2(TypedDict, total=False):
    """Arguments for Task"""
    include: 'LogIncludeFromLogRecursive3'


class LogArgsFromTaskRecursive3(TypedDict, total=False):
    """Arguments for Task"""
    include: 'LogIncludeFromLogRecursive4'


class LogArgsFromTaskRecursive4(TypedDict, total=False):
    """Arguments for Task"""
    
    

class FindManyLogArgsFromTask(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive1'


class FindManyLogArgsFromTaskRecursive1(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive2'


class FindManyLogArgsFromTaskRecursive2(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive3'


class FindManyLogArgsFromTaskRecursive3(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive4'


class FindManyLogArgsFromTaskRecursive4(TypedDict, total=False):
    """Arguments for Task"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    


FindManyTaskArgs = FindManyTaskArgsFromTask
FindFirstTaskArgs = FindManyTaskArgsFromTask


    

class TaskWhereInput(TypedDict, total=False):
    """Task arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    project: 'ProjectRelationFilter'
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    skillRequirement: Union[None, _str, 'types.StringFilter']
    priority: 'enums.Priority'
    estimatedDuration: Union[_int, 'types.IntFilter']
    deadline: Union[datetime.datetime, 'types.DateTimeFilter']
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: Union[None, _str, 'types.StringFilter']
    assignedWorker: 'WorkerRelationFilter'
    assignments: 'AssignmentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['TaskWhereInputRecursive1', List['TaskWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TaskWhereInputRecursive1']
    OR: List['TaskWhereInputRecursive1']
    NOT: List['TaskWhereInputRecursive1']


class TaskWhereInputRecursive1(TypedDict, total=False):
    """Task arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    project: 'ProjectRelationFilter'
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    skillRequirement: Union[None, _str, 'types.StringFilter']
    priority: 'enums.Priority'
    estimatedDuration: Union[_int, 'types.IntFilter']
    deadline: Union[datetime.datetime, 'types.DateTimeFilter']
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: Union[None, _str, 'types.StringFilter']
    assignedWorker: 'WorkerRelationFilter'
    assignments: 'AssignmentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['TaskWhereInputRecursive2', List['TaskWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TaskWhereInputRecursive2']
    OR: List['TaskWhereInputRecursive2']
    NOT: List['TaskWhereInputRecursive2']


class TaskWhereInputRecursive2(TypedDict, total=False):
    """Task arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    project: 'ProjectRelationFilter'
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    skillRequirement: Union[None, _str, 'types.StringFilter']
    priority: 'enums.Priority'
    estimatedDuration: Union[_int, 'types.IntFilter']
    deadline: Union[datetime.datetime, 'types.DateTimeFilter']
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: Union[None, _str, 'types.StringFilter']
    assignedWorker: 'WorkerRelationFilter'
    assignments: 'AssignmentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['TaskWhereInputRecursive3', List['TaskWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TaskWhereInputRecursive3']
    OR: List['TaskWhereInputRecursive3']
    NOT: List['TaskWhereInputRecursive3']


class TaskWhereInputRecursive3(TypedDict, total=False):
    """Task arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    project: 'ProjectRelationFilter'
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    skillRequirement: Union[None, _str, 'types.StringFilter']
    priority: 'enums.Priority'
    estimatedDuration: Union[_int, 'types.IntFilter']
    deadline: Union[datetime.datetime, 'types.DateTimeFilter']
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: Union[None, _str, 'types.StringFilter']
    assignedWorker: 'WorkerRelationFilter'
    assignments: 'AssignmentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['TaskWhereInputRecursive4', List['TaskWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TaskWhereInputRecursive4']
    OR: List['TaskWhereInputRecursive4']
    NOT: List['TaskWhereInputRecursive4']


class TaskWhereInputRecursive4(TypedDict, total=False):
    """Task arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    project: 'ProjectRelationFilter'
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    skillRequirement: Union[None, _str, 'types.StringFilter']
    priority: 'enums.Priority'
    estimatedDuration: Union[_int, 'types.IntFilter']
    deadline: Union[datetime.datetime, 'types.DateTimeFilter']
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: Union[None, _str, 'types.StringFilter']
    assignedWorker: 'WorkerRelationFilter'
    assignments: 'AssignmentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Task types


    

class TaskScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Task arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    skillRequirement: Union[_str, 'types.StringWithAggregatesFilter']
    priority: 'enums.Priority'
    estimatedDuration: Union[_int, 'types.IntWithAggregatesFilter']
    deadline: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TaskScalarWhereWithAggregatesInputRecursive1']
    OR: List['TaskScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TaskScalarWhereWithAggregatesInputRecursive1']


class TaskScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Task arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    skillRequirement: Union[_str, 'types.StringWithAggregatesFilter']
    priority: 'enums.Priority'
    estimatedDuration: Union[_int, 'types.IntWithAggregatesFilter']
    deadline: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TaskScalarWhereWithAggregatesInputRecursive2']
    OR: List['TaskScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TaskScalarWhereWithAggregatesInputRecursive2']


class TaskScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Task arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    skillRequirement: Union[_str, 'types.StringWithAggregatesFilter']
    priority: 'enums.Priority'
    estimatedDuration: Union[_int, 'types.IntWithAggregatesFilter']
    deadline: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TaskScalarWhereWithAggregatesInputRecursive3']
    OR: List['TaskScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TaskScalarWhereWithAggregatesInputRecursive3']


class TaskScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Task arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    skillRequirement: Union[_str, 'types.StringWithAggregatesFilter']
    priority: 'enums.Priority'
    estimatedDuration: Union[_int, 'types.IntWithAggregatesFilter']
    deadline: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TaskScalarWhereWithAggregatesInputRecursive4']
    OR: List['TaskScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TaskScalarWhereWithAggregatesInputRecursive4']


class TaskScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Task arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    skillRequirement: Union[_str, 'types.StringWithAggregatesFilter']
    priority: 'enums.Priority'
    estimatedDuration: Union[_int, 'types.IntWithAggregatesFilter']
    deadline: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class TaskGroupByOutput(TypedDict, total=False):
    id: _str
    projectId: _str
    name: _str
    description: _str
    skillRequirement: _str
    priority: 'enums.Priority'
    estimatedDuration: _int
    deadline: datetime.datetime
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'TaskSumAggregateOutput'
    _avg: 'TaskAvgAggregateOutput'
    _min: 'TaskMinAggregateOutput'
    _max: 'TaskMaxAggregateOutput'
    _count: 'TaskCountAggregateOutput'


class TaskAvgAggregateOutput(TypedDict, total=False):
    """Task output for aggregating averages"""
    estimatedDuration: float


class TaskSumAggregateOutput(TypedDict, total=False):
    """Task output for aggregating sums"""
    estimatedDuration: _int


class TaskScalarAggregateOutput(TypedDict, total=False):
    """Task output including scalar fields"""
    id: _str
    projectId: _str
    name: _str
    description: _str
    skillRequirement: _str
    priority: 'enums.Priority'
    estimatedDuration: _int
    deadline: datetime.datetime
    assignedTeam: 'enums.Team'
    status: 'enums.TaskStatus'
    assignedWorkerId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


TaskMinAggregateOutput = TaskScalarAggregateOutput
TaskMaxAggregateOutput = TaskScalarAggregateOutput


class TaskMaxAggregateInput(TypedDict, total=False):
    """Task input for aggregating by max"""
    id: bool
    projectId: bool
    name: bool
    description: bool
    skillRequirement: bool
    priority: bool
    estimatedDuration: bool
    deadline: bool
    assignedTeam: bool
    status: bool
    assignedWorkerId: bool
    createdAt: bool
    updatedAt: bool


class TaskMinAggregateInput(TypedDict, total=False):
    """Task input for aggregating by min"""
    id: bool
    projectId: bool
    name: bool
    description: bool
    skillRequirement: bool
    priority: bool
    estimatedDuration: bool
    deadline: bool
    assignedTeam: bool
    status: bool
    assignedWorkerId: bool
    createdAt: bool
    updatedAt: bool


class TaskNumberAggregateInput(TypedDict, total=False):
    """Task input for aggregating numbers"""
    estimatedDuration: bool


TaskAvgAggregateInput = TaskNumberAggregateInput
TaskSumAggregateInput = TaskNumberAggregateInput


TaskCountAggregateInput = TypedDict(
    'TaskCountAggregateInput',
    {
        'id': bool,
        'projectId': bool,
        'name': bool,
        'description': bool,
        'skillRequirement': bool,
        'priority': bool,
        'estimatedDuration': bool,
        'deadline': bool,
        'assignedTeam': bool,
        'status': bool,
        'assignedWorkerId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

TaskCountAggregateOutput = TypedDict(
    'TaskCountAggregateOutput',
    {
        'id': int,
        'projectId': int,
        'name': int,
        'description': int,
        'skillRequirement': int,
        'priority': int,
        'estimatedDuration': int,
        'deadline': int,
        'assignedTeam': int,
        'status': int,
        'assignedWorkerId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


TaskKeys = Literal[
    'id',
    'projectId',
    'project',
    'name',
    'description',
    'skillRequirement',
    'priority',
    'estimatedDuration',
    'deadline',
    'assignedTeam',
    'status',
    'assignedWorkerId',
    'assignedWorker',
    'assignments',
    'createdAt',
    'updatedAt',
]
TaskScalarFieldKeys = Literal[
    'id',
    'projectId',
    'name',
    'description',
    'skillRequirement',
    'priority',
    'estimatedDuration',
    'deadline',
    'assignedTeam',
    'status',
    'assignedWorkerId',
    'createdAt',
    'updatedAt',
]
TaskScalarFieldKeysT = TypeVar('TaskScalarFieldKeysT', bound=TaskScalarFieldKeys)

TaskRelationalFieldKeys = Literal[
        'project',
        'assignedWorker',
        'assignments',
    ]

# Worker types

class WorkerOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Worker create method"""
    id: _str
    status: 'enums.WorkerStatus'
    capacity: _int
    teams: List['enums.Team']
    lastHealthCheck: Optional[datetime.datetime]
    tasks: 'TaskCreateManyNestedWithoutRelationsInput'
    assignments: 'AssignmentCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class WorkerCreateInput(WorkerOptionalCreateInput):
    """Required arguments to the Worker create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class WorkerOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Worker create method, without relations"""
    id: _str
    status: 'enums.WorkerStatus'
    capacity: _int
    teams: List['enums.Team']
    lastHealthCheck: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class WorkerCreateWithoutRelationsInput(WorkerOptionalCreateWithoutRelationsInput):
    """Required arguments to the Worker create method, without relations"""

class WorkerConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'WorkerCreateWithoutRelationsInput'
    where: 'WorkerWhereUniqueInput'

class WorkerCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'WorkerCreateWithoutRelationsInput'
    connect: 'WorkerWhereUniqueInput'
    connect_or_create: 'WorkerConnectOrCreateWithoutRelationsInput'


class WorkerCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['WorkerCreateWithoutRelationsInput', List['WorkerCreateWithoutRelationsInput']]
    connect: Union['WorkerWhereUniqueInput', List['WorkerWhereUniqueInput']]
    connect_or_create: Union['WorkerConnectOrCreateWithoutRelationsInput', List['WorkerConnectOrCreateWithoutRelationsInput']]

_WorkerWhereUnique_id_Input = TypedDict(
    '_WorkerWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

WorkerWhereUniqueInput = _WorkerWhereUnique_id_Input


class WorkerUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    status: 'enums.WorkerStatus'
    capacity: Union[AtomicIntInput, _int]
    teams: 'types.TeamListUpdate'
    lastHealthCheck: Optional[datetime.datetime]
    tasks: 'TaskUpdateManyWithoutRelationsInput'
    assignments: 'AssignmentUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class WorkerUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    status: 'enums.WorkerStatus'
    capacity: Union[AtomicIntInput, _int]
    teams: 'types.TeamListUpdate'
    lastHealthCheck: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class WorkerUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['WorkerCreateWithoutRelationsInput']
    connect: List['WorkerWhereUniqueInput']
    connect_or_create: List['WorkerConnectOrCreateWithoutRelationsInput']
    set: List['WorkerWhereUniqueInput']
    disconnect: List['WorkerWhereUniqueInput']
    delete: List['WorkerWhereUniqueInput']

    # TODO
    # update: List['WorkerUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['WorkerUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['WorkerScalarWhereInput']
    # upsert: List['WorkerUpserteWithWhereUniqueWithoutRelationsInput']


class WorkerUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'WorkerCreateWithoutRelationsInput'
    connect: 'WorkerWhereUniqueInput'
    connect_or_create: 'WorkerConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'WorkerUpdateInput'
    # upsert: 'WorkerUpsertWithoutRelationsInput'


class WorkerUpsertInput(TypedDict):
    create: 'WorkerCreateInput'
    update: 'WorkerUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Worker_id_OrderByInput = TypedDict(
    '_Worker_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Worker_status_OrderByInput = TypedDict(
    '_Worker_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Worker_capacity_OrderByInput = TypedDict(
    '_Worker_capacity_OrderByInput',
    {
        'capacity': 'SortOrder',
    },
    total=True
)

_Worker_teams_OrderByInput = TypedDict(
    '_Worker_teams_OrderByInput',
    {
        'teams': 'SortOrder',
    },
    total=True
)

_Worker_lastHealthCheck_OrderByInput = TypedDict(
    '_Worker_lastHealthCheck_OrderByInput',
    {
        'lastHealthCheck': 'SortOrder',
    },
    total=True
)

_Worker_createdAt_OrderByInput = TypedDict(
    '_Worker_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Worker_updatedAt_OrderByInput = TypedDict(
    '_Worker_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Worker_RelevanceInner = TypedDict(
    '_Worker_RelevanceInner',
    {
        'fields': 'List[WorkerScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Worker_RelevanceOrderByInput = TypedDict(
    '_Worker_RelevanceOrderByInput',
    {
        '_relevance': '_Worker_RelevanceInner',
    },
    total=True
)

WorkerOrderByInput = Union[
    '_Worker_id_OrderByInput',
    '_Worker_status_OrderByInput',
    '_Worker_capacity_OrderByInput',
    '_Worker_teams_OrderByInput',
    '_Worker_lastHealthCheck_OrderByInput',
    '_Worker_createdAt_OrderByInput',
    '_Worker_updatedAt_OrderByInput',
    '_Worker_RelevanceOrderByInput',
]



# recursive Worker types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

WorkerRelationFilter = TypedDict(
    'WorkerRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class WorkerListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class WorkerInclude(TypedDict, total=False):
    """Worker relational arguments"""
    tasks: Union[bool, 'FindManyTaskArgsFromWorker']
    assignments: Union[bool, 'FindManyAssignmentArgsFromWorker']


    

class ProjectIncludeFromWorker(TypedDict, total=False):
    """Relational arguments for Worker"""
    tasks: Union[bool, 'FindManyTaskArgsFromWorkerRecursive1']


class ProjectIncludeFromWorkerRecursive1(TypedDict, total=False):
    """Relational arguments for Worker"""
    tasks: Union[bool, 'FindManyTaskArgsFromWorkerRecursive2']


class ProjectIncludeFromWorkerRecursive2(TypedDict, total=False):
    """Relational arguments for Worker"""
    tasks: Union[bool, 'FindManyTaskArgsFromWorkerRecursive3']


class ProjectIncludeFromWorkerRecursive3(TypedDict, total=False):
    """Relational arguments for Worker"""
    tasks: Union[bool, 'FindManyTaskArgsFromWorkerRecursive4']


class ProjectIncludeFromWorkerRecursive4(TypedDict, total=False):
    """Relational arguments for Worker"""

    

class ProjectArgsFromWorker(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromWorkerRecursive1(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromWorkerRecursive2(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromWorkerRecursive3(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromWorkerRecursive4(TypedDict, total=False):
    """Arguments for Worker"""
    
    

class FindManyProjectArgsFromWorker(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromWorkerRecursive1(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromWorkerRecursive2(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromWorkerRecursive3(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromWorkerRecursive4(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class TaskIncludeFromWorker(TypedDict, total=False):
    """Relational arguments for Worker"""
    project: Union[bool, 'ProjectArgsFromWorkerRecursive1']
    assignedWorker: Union[bool, 'WorkerArgsFromWorkerRecursive1']
    assignments: Union[bool, 'FindManyAssignmentArgsFromWorkerRecursive1']


class TaskIncludeFromWorkerRecursive1(TypedDict, total=False):
    """Relational arguments for Worker"""
    project: Union[bool, 'ProjectArgsFromWorkerRecursive2']
    assignedWorker: Union[bool, 'WorkerArgsFromWorkerRecursive2']
    assignments: Union[bool, 'FindManyAssignmentArgsFromWorkerRecursive2']


class TaskIncludeFromWorkerRecursive2(TypedDict, total=False):
    """Relational arguments for Worker"""
    project: Union[bool, 'ProjectArgsFromWorkerRecursive3']
    assignedWorker: Union[bool, 'WorkerArgsFromWorkerRecursive3']
    assignments: Union[bool, 'FindManyAssignmentArgsFromWorkerRecursive3']


class TaskIncludeFromWorkerRecursive3(TypedDict, total=False):
    """Relational arguments for Worker"""
    project: Union[bool, 'ProjectArgsFromWorkerRecursive4']
    assignedWorker: Union[bool, 'WorkerArgsFromWorkerRecursive4']
    assignments: Union[bool, 'FindManyAssignmentArgsFromWorkerRecursive4']


class TaskIncludeFromWorkerRecursive4(TypedDict, total=False):
    """Relational arguments for Worker"""

    

class TaskArgsFromWorker(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'TaskIncludeFromTaskRecursive1'


class TaskArgsFromWorkerRecursive1(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'TaskIncludeFromTaskRecursive2'


class TaskArgsFromWorkerRecursive2(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'TaskIncludeFromTaskRecursive3'


class TaskArgsFromWorkerRecursive3(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'TaskIncludeFromTaskRecursive4'


class TaskArgsFromWorkerRecursive4(TypedDict, total=False):
    """Arguments for Worker"""
    
    

class FindManyTaskArgsFromWorker(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive1'


class FindManyTaskArgsFromWorkerRecursive1(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive2'


class FindManyTaskArgsFromWorkerRecursive2(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive3'


class FindManyTaskArgsFromWorkerRecursive3(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive4'


class FindManyTaskArgsFromWorkerRecursive4(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    
    

class WorkerIncludeFromWorker(TypedDict, total=False):
    """Relational arguments for Worker"""
    tasks: Union[bool, 'FindManyTaskArgsFromWorkerRecursive1']
    assignments: Union[bool, 'FindManyAssignmentArgsFromWorkerRecursive1']


class WorkerIncludeFromWorkerRecursive1(TypedDict, total=False):
    """Relational arguments for Worker"""
    tasks: Union[bool, 'FindManyTaskArgsFromWorkerRecursive2']
    assignments: Union[bool, 'FindManyAssignmentArgsFromWorkerRecursive2']


class WorkerIncludeFromWorkerRecursive2(TypedDict, total=False):
    """Relational arguments for Worker"""
    tasks: Union[bool, 'FindManyTaskArgsFromWorkerRecursive3']
    assignments: Union[bool, 'FindManyAssignmentArgsFromWorkerRecursive3']


class WorkerIncludeFromWorkerRecursive3(TypedDict, total=False):
    """Relational arguments for Worker"""
    tasks: Union[bool, 'FindManyTaskArgsFromWorkerRecursive4']
    assignments: Union[bool, 'FindManyAssignmentArgsFromWorkerRecursive4']


class WorkerIncludeFromWorkerRecursive4(TypedDict, total=False):
    """Relational arguments for Worker"""

    

class WorkerArgsFromWorker(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'WorkerIncludeFromWorkerRecursive1'


class WorkerArgsFromWorkerRecursive1(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'WorkerIncludeFromWorkerRecursive2'


class WorkerArgsFromWorkerRecursive2(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'WorkerIncludeFromWorkerRecursive3'


class WorkerArgsFromWorkerRecursive3(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'WorkerIncludeFromWorkerRecursive4'


class WorkerArgsFromWorkerRecursive4(TypedDict, total=False):
    """Arguments for Worker"""
    
    

class FindManyWorkerArgsFromWorker(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive1'


class FindManyWorkerArgsFromWorkerRecursive1(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive2'


class FindManyWorkerArgsFromWorkerRecursive2(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive3'


class FindManyWorkerArgsFromWorkerRecursive3(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive4'


class FindManyWorkerArgsFromWorkerRecursive4(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    
    

class AssignmentIncludeFromWorker(TypedDict, total=False):
    """Relational arguments for Worker"""
    task: Union[bool, 'TaskArgsFromWorkerRecursive1']
    worker: Union[bool, 'WorkerArgsFromWorkerRecursive1']


class AssignmentIncludeFromWorkerRecursive1(TypedDict, total=False):
    """Relational arguments for Worker"""
    task: Union[bool, 'TaskArgsFromWorkerRecursive2']
    worker: Union[bool, 'WorkerArgsFromWorkerRecursive2']


class AssignmentIncludeFromWorkerRecursive2(TypedDict, total=False):
    """Relational arguments for Worker"""
    task: Union[bool, 'TaskArgsFromWorkerRecursive3']
    worker: Union[bool, 'WorkerArgsFromWorkerRecursive3']


class AssignmentIncludeFromWorkerRecursive3(TypedDict, total=False):
    """Relational arguments for Worker"""
    task: Union[bool, 'TaskArgsFromWorkerRecursive4']
    worker: Union[bool, 'WorkerArgsFromWorkerRecursive4']


class AssignmentIncludeFromWorkerRecursive4(TypedDict, total=False):
    """Relational arguments for Worker"""

    

class AssignmentArgsFromWorker(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'AssignmentIncludeFromAssignmentRecursive1'


class AssignmentArgsFromWorkerRecursive1(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'AssignmentIncludeFromAssignmentRecursive2'


class AssignmentArgsFromWorkerRecursive2(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'AssignmentIncludeFromAssignmentRecursive3'


class AssignmentArgsFromWorkerRecursive3(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'AssignmentIncludeFromAssignmentRecursive4'


class AssignmentArgsFromWorkerRecursive4(TypedDict, total=False):
    """Arguments for Worker"""
    
    

class FindManyAssignmentArgsFromWorker(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive1'


class FindManyAssignmentArgsFromWorkerRecursive1(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive2'


class FindManyAssignmentArgsFromWorkerRecursive2(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive3'


class FindManyAssignmentArgsFromWorkerRecursive3(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive4'


class FindManyAssignmentArgsFromWorkerRecursive4(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    
    

class LogIncludeFromWorker(TypedDict, total=False):
    """Relational arguments for Worker"""


class LogIncludeFromWorkerRecursive1(TypedDict, total=False):
    """Relational arguments for Worker"""


class LogIncludeFromWorkerRecursive2(TypedDict, total=False):
    """Relational arguments for Worker"""


class LogIncludeFromWorkerRecursive3(TypedDict, total=False):
    """Relational arguments for Worker"""


class LogIncludeFromWorkerRecursive4(TypedDict, total=False):
    """Relational arguments for Worker"""

    

class LogArgsFromWorker(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'LogIncludeFromLogRecursive1'


class LogArgsFromWorkerRecursive1(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'LogIncludeFromLogRecursive2'


class LogArgsFromWorkerRecursive2(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'LogIncludeFromLogRecursive3'


class LogArgsFromWorkerRecursive3(TypedDict, total=False):
    """Arguments for Worker"""
    include: 'LogIncludeFromLogRecursive4'


class LogArgsFromWorkerRecursive4(TypedDict, total=False):
    """Arguments for Worker"""
    
    

class FindManyLogArgsFromWorker(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive1'


class FindManyLogArgsFromWorkerRecursive1(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive2'


class FindManyLogArgsFromWorkerRecursive2(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive3'


class FindManyLogArgsFromWorkerRecursive3(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive4'


class FindManyLogArgsFromWorkerRecursive4(TypedDict, total=False):
    """Arguments for Worker"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    


FindManyWorkerArgs = FindManyWorkerArgsFromWorker
FindFirstWorkerArgs = FindManyWorkerArgsFromWorker


    

class WorkerWhereInput(TypedDict, total=False):
    """Worker arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    status: 'enums.WorkerStatus'
    capacity: Union[_int, 'types.IntFilter']
    teams: 'types.TeamListFilter'
    lastHealthCheck: Union[None, datetime.datetime, 'types.DateTimeFilter']
    tasks: 'TaskListRelationFilter'
    assignments: 'AssignmentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WorkerWhereInputRecursive1', List['WorkerWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['WorkerWhereInputRecursive1']
    OR: List['WorkerWhereInputRecursive1']
    NOT: List['WorkerWhereInputRecursive1']


class WorkerWhereInputRecursive1(TypedDict, total=False):
    """Worker arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    status: 'enums.WorkerStatus'
    capacity: Union[_int, 'types.IntFilter']
    teams: 'types.TeamListFilter'
    lastHealthCheck: Union[None, datetime.datetime, 'types.DateTimeFilter']
    tasks: 'TaskListRelationFilter'
    assignments: 'AssignmentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WorkerWhereInputRecursive2', List['WorkerWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['WorkerWhereInputRecursive2']
    OR: List['WorkerWhereInputRecursive2']
    NOT: List['WorkerWhereInputRecursive2']


class WorkerWhereInputRecursive2(TypedDict, total=False):
    """Worker arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    status: 'enums.WorkerStatus'
    capacity: Union[_int, 'types.IntFilter']
    teams: 'types.TeamListFilter'
    lastHealthCheck: Union[None, datetime.datetime, 'types.DateTimeFilter']
    tasks: 'TaskListRelationFilter'
    assignments: 'AssignmentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WorkerWhereInputRecursive3', List['WorkerWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['WorkerWhereInputRecursive3']
    OR: List['WorkerWhereInputRecursive3']
    NOT: List['WorkerWhereInputRecursive3']


class WorkerWhereInputRecursive3(TypedDict, total=False):
    """Worker arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    status: 'enums.WorkerStatus'
    capacity: Union[_int, 'types.IntFilter']
    teams: 'types.TeamListFilter'
    lastHealthCheck: Union[None, datetime.datetime, 'types.DateTimeFilter']
    tasks: 'TaskListRelationFilter'
    assignments: 'AssignmentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WorkerWhereInputRecursive4', List['WorkerWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['WorkerWhereInputRecursive4']
    OR: List['WorkerWhereInputRecursive4']
    NOT: List['WorkerWhereInputRecursive4']


class WorkerWhereInputRecursive4(TypedDict, total=False):
    """Worker arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    status: 'enums.WorkerStatus'
    capacity: Union[_int, 'types.IntFilter']
    teams: 'types.TeamListFilter'
    lastHealthCheck: Union[None, datetime.datetime, 'types.DateTimeFilter']
    tasks: 'TaskListRelationFilter'
    assignments: 'AssignmentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Worker types


    

class WorkerScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Worker arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.WorkerStatus'
    capacity: Union[_int, 'types.IntWithAggregatesFilter']
    teams: List['enums.Team']
    lastHealthCheck: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WorkerScalarWhereWithAggregatesInputRecursive1']
    OR: List['WorkerScalarWhereWithAggregatesInputRecursive1']
    NOT: List['WorkerScalarWhereWithAggregatesInputRecursive1']


class WorkerScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Worker arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.WorkerStatus'
    capacity: Union[_int, 'types.IntWithAggregatesFilter']
    teams: List['enums.Team']
    lastHealthCheck: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WorkerScalarWhereWithAggregatesInputRecursive2']
    OR: List['WorkerScalarWhereWithAggregatesInputRecursive2']
    NOT: List['WorkerScalarWhereWithAggregatesInputRecursive2']


class WorkerScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Worker arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.WorkerStatus'
    capacity: Union[_int, 'types.IntWithAggregatesFilter']
    teams: List['enums.Team']
    lastHealthCheck: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WorkerScalarWhereWithAggregatesInputRecursive3']
    OR: List['WorkerScalarWhereWithAggregatesInputRecursive3']
    NOT: List['WorkerScalarWhereWithAggregatesInputRecursive3']


class WorkerScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Worker arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.WorkerStatus'
    capacity: Union[_int, 'types.IntWithAggregatesFilter']
    teams: List['enums.Team']
    lastHealthCheck: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WorkerScalarWhereWithAggregatesInputRecursive4']
    OR: List['WorkerScalarWhereWithAggregatesInputRecursive4']
    NOT: List['WorkerScalarWhereWithAggregatesInputRecursive4']


class WorkerScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Worker arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.WorkerStatus'
    capacity: Union[_int, 'types.IntWithAggregatesFilter']
    teams: List['enums.Team']
    lastHealthCheck: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class WorkerGroupByOutput(TypedDict, total=False):
    id: _str
    status: 'enums.WorkerStatus'
    capacity: _int
    teams: List['enums.Team']
    lastHealthCheck: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'WorkerSumAggregateOutput'
    _avg: 'WorkerAvgAggregateOutput'
    _min: 'WorkerMinAggregateOutput'
    _max: 'WorkerMaxAggregateOutput'
    _count: 'WorkerCountAggregateOutput'


class WorkerAvgAggregateOutput(TypedDict, total=False):
    """Worker output for aggregating averages"""
    capacity: float


class WorkerSumAggregateOutput(TypedDict, total=False):
    """Worker output for aggregating sums"""
    capacity: _int


class WorkerScalarAggregateOutput(TypedDict, total=False):
    """Worker output including scalar fields"""
    id: _str
    status: 'enums.WorkerStatus'
    capacity: _int
    teams: List['enums.Team']
    lastHealthCheck: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


WorkerMinAggregateOutput = WorkerScalarAggregateOutput
WorkerMaxAggregateOutput = WorkerScalarAggregateOutput


class WorkerMaxAggregateInput(TypedDict, total=False):
    """Worker input for aggregating by max"""
    id: bool
    status: bool
    capacity: bool
    teams: bool
    lastHealthCheck: bool
    createdAt: bool
    updatedAt: bool


class WorkerMinAggregateInput(TypedDict, total=False):
    """Worker input for aggregating by min"""
    id: bool
    status: bool
    capacity: bool
    teams: bool
    lastHealthCheck: bool
    createdAt: bool
    updatedAt: bool


class WorkerNumberAggregateInput(TypedDict, total=False):
    """Worker input for aggregating numbers"""
    capacity: bool


WorkerAvgAggregateInput = WorkerNumberAggregateInput
WorkerSumAggregateInput = WorkerNumberAggregateInput


WorkerCountAggregateInput = TypedDict(
    'WorkerCountAggregateInput',
    {
        'id': bool,
        'status': bool,
        'capacity': bool,
        'teams': bool,
        'lastHealthCheck': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

WorkerCountAggregateOutput = TypedDict(
    'WorkerCountAggregateOutput',
    {
        'id': int,
        'status': int,
        'capacity': int,
        'teams': int,
        'lastHealthCheck': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


WorkerKeys = Literal[
    'id',
    'status',
    'capacity',
    'teams',
    'lastHealthCheck',
    'tasks',
    'assignments',
    'createdAt',
    'updatedAt',
]
WorkerScalarFieldKeys = Literal[
    'id',
    'status',
    'capacity',
    'teams',
    'lastHealthCheck',
    'createdAt',
    'updatedAt',
]
WorkerScalarFieldKeysT = TypeVar('WorkerScalarFieldKeysT', bound=WorkerScalarFieldKeys)

WorkerRelationalFieldKeys = Literal[
        'tasks',
        'assignments',
    ]

# Assignment types

class AssignmentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Assignment create method"""
    id: _str
    taskId: _str
    task: 'TaskCreateNestedWithoutRelationsInput'
    workerId: _str
    worker: 'WorkerCreateNestedWithoutRelationsInput'
    assignedAt: datetime.datetime
    completedAt: Optional[datetime.datetime]
    status: 'enums.TaskStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AssignmentCreateInput(AssignmentOptionalCreateInput):
    """Required arguments to the Assignment create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AssignmentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Assignment create method, without relations"""
    id: _str
    taskId: _str
    workerId: _str
    assignedAt: datetime.datetime
    completedAt: Optional[datetime.datetime]
    status: 'enums.TaskStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AssignmentCreateWithoutRelationsInput(AssignmentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Assignment create method, without relations"""

class AssignmentConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'AssignmentCreateWithoutRelationsInput'
    where: 'AssignmentWhereUniqueInput'

class AssignmentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AssignmentCreateWithoutRelationsInput'
    connect: 'AssignmentWhereUniqueInput'
    connect_or_create: 'AssignmentConnectOrCreateWithoutRelationsInput'


class AssignmentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AssignmentCreateWithoutRelationsInput', List['AssignmentCreateWithoutRelationsInput']]
    connect: Union['AssignmentWhereUniqueInput', List['AssignmentWhereUniqueInput']]
    connect_or_create: Union['AssignmentConnectOrCreateWithoutRelationsInput', List['AssignmentConnectOrCreateWithoutRelationsInput']]

_AssignmentWhereUnique_id_Input = TypedDict(
    '_AssignmentWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

AssignmentWhereUniqueInput = _AssignmentWhereUnique_id_Input


class AssignmentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    task: 'TaskUpdateOneWithoutRelationsInput'
    worker: 'WorkerUpdateOneWithoutRelationsInput'
    assignedAt: datetime.datetime
    completedAt: Optional[datetime.datetime]
    status: 'enums.TaskStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AssignmentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    assignedAt: datetime.datetime
    completedAt: Optional[datetime.datetime]
    status: 'enums.TaskStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AssignmentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AssignmentCreateWithoutRelationsInput']
    connect: List['AssignmentWhereUniqueInput']
    connect_or_create: List['AssignmentConnectOrCreateWithoutRelationsInput']
    set: List['AssignmentWhereUniqueInput']
    disconnect: List['AssignmentWhereUniqueInput']
    delete: List['AssignmentWhereUniqueInput']

    # TODO
    # update: List['AssignmentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AssignmentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AssignmentScalarWhereInput']
    # upsert: List['AssignmentUpserteWithWhereUniqueWithoutRelationsInput']


class AssignmentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AssignmentCreateWithoutRelationsInput'
    connect: 'AssignmentWhereUniqueInput'
    connect_or_create: 'AssignmentConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AssignmentUpdateInput'
    # upsert: 'AssignmentUpsertWithoutRelationsInput'


class AssignmentUpsertInput(TypedDict):
    create: 'AssignmentCreateInput'
    update: 'AssignmentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Assignment_id_OrderByInput = TypedDict(
    '_Assignment_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Assignment_taskId_OrderByInput = TypedDict(
    '_Assignment_taskId_OrderByInput',
    {
        'taskId': 'SortOrder',
    },
    total=True
)

_Assignment_workerId_OrderByInput = TypedDict(
    '_Assignment_workerId_OrderByInput',
    {
        'workerId': 'SortOrder',
    },
    total=True
)

_Assignment_assignedAt_OrderByInput = TypedDict(
    '_Assignment_assignedAt_OrderByInput',
    {
        'assignedAt': 'SortOrder',
    },
    total=True
)

_Assignment_completedAt_OrderByInput = TypedDict(
    '_Assignment_completedAt_OrderByInput',
    {
        'completedAt': 'SortOrder',
    },
    total=True
)

_Assignment_status_OrderByInput = TypedDict(
    '_Assignment_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Assignment_createdAt_OrderByInput = TypedDict(
    '_Assignment_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Assignment_updatedAt_OrderByInput = TypedDict(
    '_Assignment_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Assignment_RelevanceInner = TypedDict(
    '_Assignment_RelevanceInner',
    {
        'fields': 'List[AssignmentScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Assignment_RelevanceOrderByInput = TypedDict(
    '_Assignment_RelevanceOrderByInput',
    {
        '_relevance': '_Assignment_RelevanceInner',
    },
    total=True
)

AssignmentOrderByInput = Union[
    '_Assignment_id_OrderByInput',
    '_Assignment_taskId_OrderByInput',
    '_Assignment_workerId_OrderByInput',
    '_Assignment_assignedAt_OrderByInput',
    '_Assignment_completedAt_OrderByInput',
    '_Assignment_status_OrderByInput',
    '_Assignment_createdAt_OrderByInput',
    '_Assignment_updatedAt_OrderByInput',
    '_Assignment_RelevanceOrderByInput',
]



# recursive Assignment types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

AssignmentRelationFilter = TypedDict(
    'AssignmentRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class AssignmentListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class AssignmentInclude(TypedDict, total=False):
    """Assignment relational arguments"""
    task: Union[bool, 'TaskArgsFromAssignment']
    worker: Union[bool, 'WorkerArgsFromAssignment']


    

class ProjectIncludeFromAssignment(TypedDict, total=False):
    """Relational arguments for Assignment"""
    tasks: Union[bool, 'FindManyTaskArgsFromAssignmentRecursive1']


class ProjectIncludeFromAssignmentRecursive1(TypedDict, total=False):
    """Relational arguments for Assignment"""
    tasks: Union[bool, 'FindManyTaskArgsFromAssignmentRecursive2']


class ProjectIncludeFromAssignmentRecursive2(TypedDict, total=False):
    """Relational arguments for Assignment"""
    tasks: Union[bool, 'FindManyTaskArgsFromAssignmentRecursive3']


class ProjectIncludeFromAssignmentRecursive3(TypedDict, total=False):
    """Relational arguments for Assignment"""
    tasks: Union[bool, 'FindManyTaskArgsFromAssignmentRecursive4']


class ProjectIncludeFromAssignmentRecursive4(TypedDict, total=False):
    """Relational arguments for Assignment"""

    

class ProjectArgsFromAssignment(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromAssignmentRecursive1(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromAssignmentRecursive2(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromAssignmentRecursive3(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromAssignmentRecursive4(TypedDict, total=False):
    """Arguments for Assignment"""
    
    

class FindManyProjectArgsFromAssignment(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromAssignmentRecursive1(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromAssignmentRecursive2(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromAssignmentRecursive3(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromAssignmentRecursive4(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class TaskIncludeFromAssignment(TypedDict, total=False):
    """Relational arguments for Assignment"""
    project: Union[bool, 'ProjectArgsFromAssignmentRecursive1']
    assignedWorker: Union[bool, 'WorkerArgsFromAssignmentRecursive1']
    assignments: Union[bool, 'FindManyAssignmentArgsFromAssignmentRecursive1']


class TaskIncludeFromAssignmentRecursive1(TypedDict, total=False):
    """Relational arguments for Assignment"""
    project: Union[bool, 'ProjectArgsFromAssignmentRecursive2']
    assignedWorker: Union[bool, 'WorkerArgsFromAssignmentRecursive2']
    assignments: Union[bool, 'FindManyAssignmentArgsFromAssignmentRecursive2']


class TaskIncludeFromAssignmentRecursive2(TypedDict, total=False):
    """Relational arguments for Assignment"""
    project: Union[bool, 'ProjectArgsFromAssignmentRecursive3']
    assignedWorker: Union[bool, 'WorkerArgsFromAssignmentRecursive3']
    assignments: Union[bool, 'FindManyAssignmentArgsFromAssignmentRecursive3']


class TaskIncludeFromAssignmentRecursive3(TypedDict, total=False):
    """Relational arguments for Assignment"""
    project: Union[bool, 'ProjectArgsFromAssignmentRecursive4']
    assignedWorker: Union[bool, 'WorkerArgsFromAssignmentRecursive4']
    assignments: Union[bool, 'FindManyAssignmentArgsFromAssignmentRecursive4']


class TaskIncludeFromAssignmentRecursive4(TypedDict, total=False):
    """Relational arguments for Assignment"""

    

class TaskArgsFromAssignment(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'TaskIncludeFromTaskRecursive1'


class TaskArgsFromAssignmentRecursive1(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'TaskIncludeFromTaskRecursive2'


class TaskArgsFromAssignmentRecursive2(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'TaskIncludeFromTaskRecursive3'


class TaskArgsFromAssignmentRecursive3(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'TaskIncludeFromTaskRecursive4'


class TaskArgsFromAssignmentRecursive4(TypedDict, total=False):
    """Arguments for Assignment"""
    
    

class FindManyTaskArgsFromAssignment(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive1'


class FindManyTaskArgsFromAssignmentRecursive1(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive2'


class FindManyTaskArgsFromAssignmentRecursive2(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive3'


class FindManyTaskArgsFromAssignmentRecursive3(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive4'


class FindManyTaskArgsFromAssignmentRecursive4(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    
    

class WorkerIncludeFromAssignment(TypedDict, total=False):
    """Relational arguments for Assignment"""
    tasks: Union[bool, 'FindManyTaskArgsFromAssignmentRecursive1']
    assignments: Union[bool, 'FindManyAssignmentArgsFromAssignmentRecursive1']


class WorkerIncludeFromAssignmentRecursive1(TypedDict, total=False):
    """Relational arguments for Assignment"""
    tasks: Union[bool, 'FindManyTaskArgsFromAssignmentRecursive2']
    assignments: Union[bool, 'FindManyAssignmentArgsFromAssignmentRecursive2']


class WorkerIncludeFromAssignmentRecursive2(TypedDict, total=False):
    """Relational arguments for Assignment"""
    tasks: Union[bool, 'FindManyTaskArgsFromAssignmentRecursive3']
    assignments: Union[bool, 'FindManyAssignmentArgsFromAssignmentRecursive3']


class WorkerIncludeFromAssignmentRecursive3(TypedDict, total=False):
    """Relational arguments for Assignment"""
    tasks: Union[bool, 'FindManyTaskArgsFromAssignmentRecursive4']
    assignments: Union[bool, 'FindManyAssignmentArgsFromAssignmentRecursive4']


class WorkerIncludeFromAssignmentRecursive4(TypedDict, total=False):
    """Relational arguments for Assignment"""

    

class WorkerArgsFromAssignment(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'WorkerIncludeFromWorkerRecursive1'


class WorkerArgsFromAssignmentRecursive1(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'WorkerIncludeFromWorkerRecursive2'


class WorkerArgsFromAssignmentRecursive2(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'WorkerIncludeFromWorkerRecursive3'


class WorkerArgsFromAssignmentRecursive3(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'WorkerIncludeFromWorkerRecursive4'


class WorkerArgsFromAssignmentRecursive4(TypedDict, total=False):
    """Arguments for Assignment"""
    
    

class FindManyWorkerArgsFromAssignment(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive1'


class FindManyWorkerArgsFromAssignmentRecursive1(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive2'


class FindManyWorkerArgsFromAssignmentRecursive2(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive3'


class FindManyWorkerArgsFromAssignmentRecursive3(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive4'


class FindManyWorkerArgsFromAssignmentRecursive4(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    
    

class AssignmentIncludeFromAssignment(TypedDict, total=False):
    """Relational arguments for Assignment"""
    task: Union[bool, 'TaskArgsFromAssignmentRecursive1']
    worker: Union[bool, 'WorkerArgsFromAssignmentRecursive1']


class AssignmentIncludeFromAssignmentRecursive1(TypedDict, total=False):
    """Relational arguments for Assignment"""
    task: Union[bool, 'TaskArgsFromAssignmentRecursive2']
    worker: Union[bool, 'WorkerArgsFromAssignmentRecursive2']


class AssignmentIncludeFromAssignmentRecursive2(TypedDict, total=False):
    """Relational arguments for Assignment"""
    task: Union[bool, 'TaskArgsFromAssignmentRecursive3']
    worker: Union[bool, 'WorkerArgsFromAssignmentRecursive3']


class AssignmentIncludeFromAssignmentRecursive3(TypedDict, total=False):
    """Relational arguments for Assignment"""
    task: Union[bool, 'TaskArgsFromAssignmentRecursive4']
    worker: Union[bool, 'WorkerArgsFromAssignmentRecursive4']


class AssignmentIncludeFromAssignmentRecursive4(TypedDict, total=False):
    """Relational arguments for Assignment"""

    

class AssignmentArgsFromAssignment(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'AssignmentIncludeFromAssignmentRecursive1'


class AssignmentArgsFromAssignmentRecursive1(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'AssignmentIncludeFromAssignmentRecursive2'


class AssignmentArgsFromAssignmentRecursive2(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'AssignmentIncludeFromAssignmentRecursive3'


class AssignmentArgsFromAssignmentRecursive3(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'AssignmentIncludeFromAssignmentRecursive4'


class AssignmentArgsFromAssignmentRecursive4(TypedDict, total=False):
    """Arguments for Assignment"""
    
    

class FindManyAssignmentArgsFromAssignment(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive1'


class FindManyAssignmentArgsFromAssignmentRecursive1(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive2'


class FindManyAssignmentArgsFromAssignmentRecursive2(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive3'


class FindManyAssignmentArgsFromAssignmentRecursive3(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive4'


class FindManyAssignmentArgsFromAssignmentRecursive4(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    
    

class LogIncludeFromAssignment(TypedDict, total=False):
    """Relational arguments for Assignment"""


class LogIncludeFromAssignmentRecursive1(TypedDict, total=False):
    """Relational arguments for Assignment"""


class LogIncludeFromAssignmentRecursive2(TypedDict, total=False):
    """Relational arguments for Assignment"""


class LogIncludeFromAssignmentRecursive3(TypedDict, total=False):
    """Relational arguments for Assignment"""


class LogIncludeFromAssignmentRecursive4(TypedDict, total=False):
    """Relational arguments for Assignment"""

    

class LogArgsFromAssignment(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'LogIncludeFromLogRecursive1'


class LogArgsFromAssignmentRecursive1(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'LogIncludeFromLogRecursive2'


class LogArgsFromAssignmentRecursive2(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'LogIncludeFromLogRecursive3'


class LogArgsFromAssignmentRecursive3(TypedDict, total=False):
    """Arguments for Assignment"""
    include: 'LogIncludeFromLogRecursive4'


class LogArgsFromAssignmentRecursive4(TypedDict, total=False):
    """Arguments for Assignment"""
    
    

class FindManyLogArgsFromAssignment(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive1'


class FindManyLogArgsFromAssignmentRecursive1(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive2'


class FindManyLogArgsFromAssignmentRecursive2(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive3'


class FindManyLogArgsFromAssignmentRecursive3(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive4'


class FindManyLogArgsFromAssignmentRecursive4(TypedDict, total=False):
    """Arguments for Assignment"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    


FindManyAssignmentArgs = FindManyAssignmentArgsFromAssignment
FindFirstAssignmentArgs = FindManyAssignmentArgsFromAssignment


    

class AssignmentWhereInput(TypedDict, total=False):
    """Assignment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    taskId: Union[_str, 'types.StringFilter']
    task: 'TaskRelationFilter'
    workerId: Union[_str, 'types.StringFilter']
    worker: 'WorkerRelationFilter'
    assignedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    completedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.TaskStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['AssignmentWhereInputRecursive1', List['AssignmentWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['AssignmentWhereInputRecursive1']
    OR: List['AssignmentWhereInputRecursive1']
    NOT: List['AssignmentWhereInputRecursive1']


class AssignmentWhereInputRecursive1(TypedDict, total=False):
    """Assignment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    taskId: Union[_str, 'types.StringFilter']
    task: 'TaskRelationFilter'
    workerId: Union[_str, 'types.StringFilter']
    worker: 'WorkerRelationFilter'
    assignedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    completedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.TaskStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['AssignmentWhereInputRecursive2', List['AssignmentWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['AssignmentWhereInputRecursive2']
    OR: List['AssignmentWhereInputRecursive2']
    NOT: List['AssignmentWhereInputRecursive2']


class AssignmentWhereInputRecursive2(TypedDict, total=False):
    """Assignment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    taskId: Union[_str, 'types.StringFilter']
    task: 'TaskRelationFilter'
    workerId: Union[_str, 'types.StringFilter']
    worker: 'WorkerRelationFilter'
    assignedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    completedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.TaskStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['AssignmentWhereInputRecursive3', List['AssignmentWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['AssignmentWhereInputRecursive3']
    OR: List['AssignmentWhereInputRecursive3']
    NOT: List['AssignmentWhereInputRecursive3']


class AssignmentWhereInputRecursive3(TypedDict, total=False):
    """Assignment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    taskId: Union[_str, 'types.StringFilter']
    task: 'TaskRelationFilter'
    workerId: Union[_str, 'types.StringFilter']
    worker: 'WorkerRelationFilter'
    assignedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    completedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.TaskStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['AssignmentWhereInputRecursive4', List['AssignmentWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['AssignmentWhereInputRecursive4']
    OR: List['AssignmentWhereInputRecursive4']
    NOT: List['AssignmentWhereInputRecursive4']


class AssignmentWhereInputRecursive4(TypedDict, total=False):
    """Assignment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    taskId: Union[_str, 'types.StringFilter']
    task: 'TaskRelationFilter'
    workerId: Union[_str, 'types.StringFilter']
    worker: 'WorkerRelationFilter'
    assignedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    completedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.TaskStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Assignment types


    

class AssignmentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Assignment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    taskId: Union[_str, 'types.StringWithAggregatesFilter']
    workerId: Union[_str, 'types.StringWithAggregatesFilter']
    assignedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    completedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.TaskStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AssignmentScalarWhereWithAggregatesInputRecursive1']
    OR: List['AssignmentScalarWhereWithAggregatesInputRecursive1']
    NOT: List['AssignmentScalarWhereWithAggregatesInputRecursive1']


class AssignmentScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Assignment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    taskId: Union[_str, 'types.StringWithAggregatesFilter']
    workerId: Union[_str, 'types.StringWithAggregatesFilter']
    assignedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    completedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.TaskStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AssignmentScalarWhereWithAggregatesInputRecursive2']
    OR: List['AssignmentScalarWhereWithAggregatesInputRecursive2']
    NOT: List['AssignmentScalarWhereWithAggregatesInputRecursive2']


class AssignmentScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Assignment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    taskId: Union[_str, 'types.StringWithAggregatesFilter']
    workerId: Union[_str, 'types.StringWithAggregatesFilter']
    assignedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    completedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.TaskStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AssignmentScalarWhereWithAggregatesInputRecursive3']
    OR: List['AssignmentScalarWhereWithAggregatesInputRecursive3']
    NOT: List['AssignmentScalarWhereWithAggregatesInputRecursive3']


class AssignmentScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Assignment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    taskId: Union[_str, 'types.StringWithAggregatesFilter']
    workerId: Union[_str, 'types.StringWithAggregatesFilter']
    assignedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    completedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.TaskStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AssignmentScalarWhereWithAggregatesInputRecursive4']
    OR: List['AssignmentScalarWhereWithAggregatesInputRecursive4']
    NOT: List['AssignmentScalarWhereWithAggregatesInputRecursive4']


class AssignmentScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Assignment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    taskId: Union[_str, 'types.StringWithAggregatesFilter']
    workerId: Union[_str, 'types.StringWithAggregatesFilter']
    assignedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    completedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.TaskStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class AssignmentGroupByOutput(TypedDict, total=False):
    id: _str
    taskId: _str
    workerId: _str
    assignedAt: datetime.datetime
    completedAt: datetime.datetime
    status: 'enums.TaskStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'AssignmentSumAggregateOutput'
    _avg: 'AssignmentAvgAggregateOutput'
    _min: 'AssignmentMinAggregateOutput'
    _max: 'AssignmentMaxAggregateOutput'
    _count: 'AssignmentCountAggregateOutput'


class AssignmentAvgAggregateOutput(TypedDict, total=False):
    """Assignment output for aggregating averages"""


class AssignmentSumAggregateOutput(TypedDict, total=False):
    """Assignment output for aggregating sums"""


class AssignmentScalarAggregateOutput(TypedDict, total=False):
    """Assignment output including scalar fields"""
    id: _str
    taskId: _str
    workerId: _str
    assignedAt: datetime.datetime
    completedAt: datetime.datetime
    status: 'enums.TaskStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


AssignmentMinAggregateOutput = AssignmentScalarAggregateOutput
AssignmentMaxAggregateOutput = AssignmentScalarAggregateOutput


class AssignmentMaxAggregateInput(TypedDict, total=False):
    """Assignment input for aggregating by max"""
    id: bool
    taskId: bool
    workerId: bool
    assignedAt: bool
    completedAt: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class AssignmentMinAggregateInput(TypedDict, total=False):
    """Assignment input for aggregating by min"""
    id: bool
    taskId: bool
    workerId: bool
    assignedAt: bool
    completedAt: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class AssignmentNumberAggregateInput(TypedDict, total=False):
    """Assignment input for aggregating numbers"""


AssignmentAvgAggregateInput = AssignmentNumberAggregateInput
AssignmentSumAggregateInput = AssignmentNumberAggregateInput


AssignmentCountAggregateInput = TypedDict(
    'AssignmentCountAggregateInput',
    {
        'id': bool,
        'taskId': bool,
        'workerId': bool,
        'assignedAt': bool,
        'completedAt': bool,
        'status': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

AssignmentCountAggregateOutput = TypedDict(
    'AssignmentCountAggregateOutput',
    {
        'id': int,
        'taskId': int,
        'workerId': int,
        'assignedAt': int,
        'completedAt': int,
        'status': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


AssignmentKeys = Literal[
    'id',
    'taskId',
    'task',
    'workerId',
    'worker',
    'assignedAt',
    'completedAt',
    'status',
    'createdAt',
    'updatedAt',
]
AssignmentScalarFieldKeys = Literal[
    'id',
    'taskId',
    'workerId',
    'assignedAt',
    'completedAt',
    'status',
    'createdAt',
    'updatedAt',
]
AssignmentScalarFieldKeysT = TypeVar('AssignmentScalarFieldKeysT', bound=AssignmentScalarFieldKeys)

AssignmentRelationalFieldKeys = Literal[
        'task',
        'worker',
    ]

# Log types

class LogOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Log create method"""
    id: _str
    timestamp: datetime.datetime
    createdAt: datetime.datetime


class LogCreateInput(LogOptionalCreateInput):
    """Required arguments to the Log create method"""
    level: _str
    message: _str
    component: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class LogOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Log create method, without relations"""
    id: _str
    timestamp: datetime.datetime
    createdAt: datetime.datetime


class LogCreateWithoutRelationsInput(LogOptionalCreateWithoutRelationsInput):
    """Required arguments to the Log create method, without relations"""
    level: _str
    message: _str
    component: _str

class LogConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'LogCreateWithoutRelationsInput'
    where: 'LogWhereUniqueInput'

class LogCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'LogCreateWithoutRelationsInput'
    connect: 'LogWhereUniqueInput'
    connect_or_create: 'LogConnectOrCreateWithoutRelationsInput'


class LogCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['LogCreateWithoutRelationsInput', List['LogCreateWithoutRelationsInput']]
    connect: Union['LogWhereUniqueInput', List['LogWhereUniqueInput']]
    connect_or_create: Union['LogConnectOrCreateWithoutRelationsInput', List['LogConnectOrCreateWithoutRelationsInput']]

_LogWhereUnique_id_Input = TypedDict(
    '_LogWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

LogWhereUniqueInput = _LogWhereUnique_id_Input


class LogUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    timestamp: datetime.datetime
    level: _str
    message: _str
    component: _str
    createdAt: datetime.datetime


class LogUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    timestamp: datetime.datetime
    level: _str
    message: _str
    component: _str
    createdAt: datetime.datetime


class LogUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['LogCreateWithoutRelationsInput']
    connect: List['LogWhereUniqueInput']
    connect_or_create: List['LogConnectOrCreateWithoutRelationsInput']
    set: List['LogWhereUniqueInput']
    disconnect: List['LogWhereUniqueInput']
    delete: List['LogWhereUniqueInput']

    # TODO
    # update: List['LogUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['LogUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['LogScalarWhereInput']
    # upsert: List['LogUpserteWithWhereUniqueWithoutRelationsInput']


class LogUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'LogCreateWithoutRelationsInput'
    connect: 'LogWhereUniqueInput'
    connect_or_create: 'LogConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'LogUpdateInput'
    # upsert: 'LogUpsertWithoutRelationsInput'


class LogUpsertInput(TypedDict):
    create: 'LogCreateInput'
    update: 'LogUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Log_id_OrderByInput = TypedDict(
    '_Log_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Log_timestamp_OrderByInput = TypedDict(
    '_Log_timestamp_OrderByInput',
    {
        'timestamp': 'SortOrder',
    },
    total=True
)

_Log_level_OrderByInput = TypedDict(
    '_Log_level_OrderByInput',
    {
        'level': 'SortOrder',
    },
    total=True
)

_Log_message_OrderByInput = TypedDict(
    '_Log_message_OrderByInput',
    {
        'message': 'SortOrder',
    },
    total=True
)

_Log_component_OrderByInput = TypedDict(
    '_Log_component_OrderByInput',
    {
        'component': 'SortOrder',
    },
    total=True
)

_Log_createdAt_OrderByInput = TypedDict(
    '_Log_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Log_RelevanceInner = TypedDict(
    '_Log_RelevanceInner',
    {
        'fields': 'List[LogScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Log_RelevanceOrderByInput = TypedDict(
    '_Log_RelevanceOrderByInput',
    {
        '_relevance': '_Log_RelevanceInner',
    },
    total=True
)

LogOrderByInput = Union[
    '_Log_id_OrderByInput',
    '_Log_timestamp_OrderByInput',
    '_Log_level_OrderByInput',
    '_Log_message_OrderByInput',
    '_Log_component_OrderByInput',
    '_Log_createdAt_OrderByInput',
    '_Log_RelevanceOrderByInput',
]



# recursive Log types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

LogRelationFilter = TypedDict(
    'LogRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class LogListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class LogInclude(TypedDict, total=False):
    """Log relational arguments"""


    

class ProjectIncludeFromLog(TypedDict, total=False):
    """Relational arguments for Log"""
    tasks: Union[bool, 'FindManyTaskArgsFromLogRecursive1']


class ProjectIncludeFromLogRecursive1(TypedDict, total=False):
    """Relational arguments for Log"""
    tasks: Union[bool, 'FindManyTaskArgsFromLogRecursive2']


class ProjectIncludeFromLogRecursive2(TypedDict, total=False):
    """Relational arguments for Log"""
    tasks: Union[bool, 'FindManyTaskArgsFromLogRecursive3']


class ProjectIncludeFromLogRecursive3(TypedDict, total=False):
    """Relational arguments for Log"""
    tasks: Union[bool, 'FindManyTaskArgsFromLogRecursive4']


class ProjectIncludeFromLogRecursive4(TypedDict, total=False):
    """Relational arguments for Log"""

    

class ProjectArgsFromLog(TypedDict, total=False):
    """Arguments for Log"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromLogRecursive1(TypedDict, total=False):
    """Arguments for Log"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromLogRecursive2(TypedDict, total=False):
    """Arguments for Log"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromLogRecursive3(TypedDict, total=False):
    """Arguments for Log"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromLogRecursive4(TypedDict, total=False):
    """Arguments for Log"""
    
    

class FindManyProjectArgsFromLog(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromLogRecursive1(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromLogRecursive2(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromLogRecursive3(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromLogRecursive4(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class TaskIncludeFromLog(TypedDict, total=False):
    """Relational arguments for Log"""
    project: Union[bool, 'ProjectArgsFromLogRecursive1']
    assignedWorker: Union[bool, 'WorkerArgsFromLogRecursive1']
    assignments: Union[bool, 'FindManyAssignmentArgsFromLogRecursive1']


class TaskIncludeFromLogRecursive1(TypedDict, total=False):
    """Relational arguments for Log"""
    project: Union[bool, 'ProjectArgsFromLogRecursive2']
    assignedWorker: Union[bool, 'WorkerArgsFromLogRecursive2']
    assignments: Union[bool, 'FindManyAssignmentArgsFromLogRecursive2']


class TaskIncludeFromLogRecursive2(TypedDict, total=False):
    """Relational arguments for Log"""
    project: Union[bool, 'ProjectArgsFromLogRecursive3']
    assignedWorker: Union[bool, 'WorkerArgsFromLogRecursive3']
    assignments: Union[bool, 'FindManyAssignmentArgsFromLogRecursive3']


class TaskIncludeFromLogRecursive3(TypedDict, total=False):
    """Relational arguments for Log"""
    project: Union[bool, 'ProjectArgsFromLogRecursive4']
    assignedWorker: Union[bool, 'WorkerArgsFromLogRecursive4']
    assignments: Union[bool, 'FindManyAssignmentArgsFromLogRecursive4']


class TaskIncludeFromLogRecursive4(TypedDict, total=False):
    """Relational arguments for Log"""

    

class TaskArgsFromLog(TypedDict, total=False):
    """Arguments for Log"""
    include: 'TaskIncludeFromTaskRecursive1'


class TaskArgsFromLogRecursive1(TypedDict, total=False):
    """Arguments for Log"""
    include: 'TaskIncludeFromTaskRecursive2'


class TaskArgsFromLogRecursive2(TypedDict, total=False):
    """Arguments for Log"""
    include: 'TaskIncludeFromTaskRecursive3'


class TaskArgsFromLogRecursive3(TypedDict, total=False):
    """Arguments for Log"""
    include: 'TaskIncludeFromTaskRecursive4'


class TaskArgsFromLogRecursive4(TypedDict, total=False):
    """Arguments for Log"""
    
    

class FindManyTaskArgsFromLog(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive1'


class FindManyTaskArgsFromLogRecursive1(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive2'


class FindManyTaskArgsFromLogRecursive2(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive3'


class FindManyTaskArgsFromLogRecursive3(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    include: 'TaskIncludeFromTaskRecursive4'


class FindManyTaskArgsFromLogRecursive4(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['TaskOrderByInput', List['TaskOrderByInput']]
    where: 'TaskWhereInput'
    cursor: 'TaskWhereUniqueInput'
    distinct: List['TaskScalarFieldKeys']
    
    

class WorkerIncludeFromLog(TypedDict, total=False):
    """Relational arguments for Log"""
    tasks: Union[bool, 'FindManyTaskArgsFromLogRecursive1']
    assignments: Union[bool, 'FindManyAssignmentArgsFromLogRecursive1']


class WorkerIncludeFromLogRecursive1(TypedDict, total=False):
    """Relational arguments for Log"""
    tasks: Union[bool, 'FindManyTaskArgsFromLogRecursive2']
    assignments: Union[bool, 'FindManyAssignmentArgsFromLogRecursive2']


class WorkerIncludeFromLogRecursive2(TypedDict, total=False):
    """Relational arguments for Log"""
    tasks: Union[bool, 'FindManyTaskArgsFromLogRecursive3']
    assignments: Union[bool, 'FindManyAssignmentArgsFromLogRecursive3']


class WorkerIncludeFromLogRecursive3(TypedDict, total=False):
    """Relational arguments for Log"""
    tasks: Union[bool, 'FindManyTaskArgsFromLogRecursive4']
    assignments: Union[bool, 'FindManyAssignmentArgsFromLogRecursive4']


class WorkerIncludeFromLogRecursive4(TypedDict, total=False):
    """Relational arguments for Log"""

    

class WorkerArgsFromLog(TypedDict, total=False):
    """Arguments for Log"""
    include: 'WorkerIncludeFromWorkerRecursive1'


class WorkerArgsFromLogRecursive1(TypedDict, total=False):
    """Arguments for Log"""
    include: 'WorkerIncludeFromWorkerRecursive2'


class WorkerArgsFromLogRecursive2(TypedDict, total=False):
    """Arguments for Log"""
    include: 'WorkerIncludeFromWorkerRecursive3'


class WorkerArgsFromLogRecursive3(TypedDict, total=False):
    """Arguments for Log"""
    include: 'WorkerIncludeFromWorkerRecursive4'


class WorkerArgsFromLogRecursive4(TypedDict, total=False):
    """Arguments for Log"""
    
    

class FindManyWorkerArgsFromLog(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive1'


class FindManyWorkerArgsFromLogRecursive1(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive2'


class FindManyWorkerArgsFromLogRecursive2(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive3'


class FindManyWorkerArgsFromLogRecursive3(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    include: 'WorkerIncludeFromWorkerRecursive4'


class FindManyWorkerArgsFromLogRecursive4(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['WorkerOrderByInput', List['WorkerOrderByInput']]
    where: 'WorkerWhereInput'
    cursor: 'WorkerWhereUniqueInput'
    distinct: List['WorkerScalarFieldKeys']
    
    

class AssignmentIncludeFromLog(TypedDict, total=False):
    """Relational arguments for Log"""
    task: Union[bool, 'TaskArgsFromLogRecursive1']
    worker: Union[bool, 'WorkerArgsFromLogRecursive1']


class AssignmentIncludeFromLogRecursive1(TypedDict, total=False):
    """Relational arguments for Log"""
    task: Union[bool, 'TaskArgsFromLogRecursive2']
    worker: Union[bool, 'WorkerArgsFromLogRecursive2']


class AssignmentIncludeFromLogRecursive2(TypedDict, total=False):
    """Relational arguments for Log"""
    task: Union[bool, 'TaskArgsFromLogRecursive3']
    worker: Union[bool, 'WorkerArgsFromLogRecursive3']


class AssignmentIncludeFromLogRecursive3(TypedDict, total=False):
    """Relational arguments for Log"""
    task: Union[bool, 'TaskArgsFromLogRecursive4']
    worker: Union[bool, 'WorkerArgsFromLogRecursive4']


class AssignmentIncludeFromLogRecursive4(TypedDict, total=False):
    """Relational arguments for Log"""

    

class AssignmentArgsFromLog(TypedDict, total=False):
    """Arguments for Log"""
    include: 'AssignmentIncludeFromAssignmentRecursive1'


class AssignmentArgsFromLogRecursive1(TypedDict, total=False):
    """Arguments for Log"""
    include: 'AssignmentIncludeFromAssignmentRecursive2'


class AssignmentArgsFromLogRecursive2(TypedDict, total=False):
    """Arguments for Log"""
    include: 'AssignmentIncludeFromAssignmentRecursive3'


class AssignmentArgsFromLogRecursive3(TypedDict, total=False):
    """Arguments for Log"""
    include: 'AssignmentIncludeFromAssignmentRecursive4'


class AssignmentArgsFromLogRecursive4(TypedDict, total=False):
    """Arguments for Log"""
    
    

class FindManyAssignmentArgsFromLog(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive1'


class FindManyAssignmentArgsFromLogRecursive1(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive2'


class FindManyAssignmentArgsFromLogRecursive2(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive3'


class FindManyAssignmentArgsFromLogRecursive3(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    include: 'AssignmentIncludeFromAssignmentRecursive4'


class FindManyAssignmentArgsFromLogRecursive4(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['AssignmentOrderByInput', List['AssignmentOrderByInput']]
    where: 'AssignmentWhereInput'
    cursor: 'AssignmentWhereUniqueInput'
    distinct: List['AssignmentScalarFieldKeys']
    
    

class LogIncludeFromLog(TypedDict, total=False):
    """Relational arguments for Log"""


class LogIncludeFromLogRecursive1(TypedDict, total=False):
    """Relational arguments for Log"""


class LogIncludeFromLogRecursive2(TypedDict, total=False):
    """Relational arguments for Log"""


class LogIncludeFromLogRecursive3(TypedDict, total=False):
    """Relational arguments for Log"""


class LogIncludeFromLogRecursive4(TypedDict, total=False):
    """Relational arguments for Log"""

    

class LogArgsFromLog(TypedDict, total=False):
    """Arguments for Log"""
    include: 'LogIncludeFromLogRecursive1'


class LogArgsFromLogRecursive1(TypedDict, total=False):
    """Arguments for Log"""
    include: 'LogIncludeFromLogRecursive2'


class LogArgsFromLogRecursive2(TypedDict, total=False):
    """Arguments for Log"""
    include: 'LogIncludeFromLogRecursive3'


class LogArgsFromLogRecursive3(TypedDict, total=False):
    """Arguments for Log"""
    include: 'LogIncludeFromLogRecursive4'


class LogArgsFromLogRecursive4(TypedDict, total=False):
    """Arguments for Log"""
    
    

class FindManyLogArgsFromLog(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive1'


class FindManyLogArgsFromLogRecursive1(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive2'


class FindManyLogArgsFromLogRecursive2(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive3'


class FindManyLogArgsFromLogRecursive3(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    include: 'LogIncludeFromLogRecursive4'


class FindManyLogArgsFromLogRecursive4(TypedDict, total=False):
    """Arguments for Log"""
    take: int
    skip: int
    order_by: Union['LogOrderByInput', List['LogOrderByInput']]
    where: 'LogWhereInput'
    cursor: 'LogWhereUniqueInput'
    distinct: List['LogScalarFieldKeys']
    


FindManyLogArgs = FindManyLogArgsFromLog
FindFirstLogArgs = FindManyLogArgsFromLog


    

class LogWhereInput(TypedDict, total=False):
    """Log arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    level: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    component: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['LogWhereInputRecursive1', List['LogWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['LogWhereInputRecursive1']
    OR: List['LogWhereInputRecursive1']
    NOT: List['LogWhereInputRecursive1']


class LogWhereInputRecursive1(TypedDict, total=False):
    """Log arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    level: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    component: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['LogWhereInputRecursive2', List['LogWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['LogWhereInputRecursive2']
    OR: List['LogWhereInputRecursive2']
    NOT: List['LogWhereInputRecursive2']


class LogWhereInputRecursive2(TypedDict, total=False):
    """Log arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    level: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    component: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['LogWhereInputRecursive3', List['LogWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['LogWhereInputRecursive3']
    OR: List['LogWhereInputRecursive3']
    NOT: List['LogWhereInputRecursive3']


class LogWhereInputRecursive3(TypedDict, total=False):
    """Log arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    level: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    component: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['LogWhereInputRecursive4', List['LogWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['LogWhereInputRecursive4']
    OR: List['LogWhereInputRecursive4']
    NOT: List['LogWhereInputRecursive4']


class LogWhereInputRecursive4(TypedDict, total=False):
    """Log arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    level: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    component: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Log types


    

class LogScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Log arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    component: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['LogScalarWhereWithAggregatesInputRecursive1']
    OR: List['LogScalarWhereWithAggregatesInputRecursive1']
    NOT: List['LogScalarWhereWithAggregatesInputRecursive1']


class LogScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Log arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    component: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['LogScalarWhereWithAggregatesInputRecursive2']
    OR: List['LogScalarWhereWithAggregatesInputRecursive2']
    NOT: List['LogScalarWhereWithAggregatesInputRecursive2']


class LogScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Log arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    component: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['LogScalarWhereWithAggregatesInputRecursive3']
    OR: List['LogScalarWhereWithAggregatesInputRecursive3']
    NOT: List['LogScalarWhereWithAggregatesInputRecursive3']


class LogScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Log arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    component: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['LogScalarWhereWithAggregatesInputRecursive4']
    OR: List['LogScalarWhereWithAggregatesInputRecursive4']
    NOT: List['LogScalarWhereWithAggregatesInputRecursive4']


class LogScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Log arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    level: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    component: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class LogGroupByOutput(TypedDict, total=False):
    id: _str
    timestamp: datetime.datetime
    level: _str
    message: _str
    component: _str
    createdAt: datetime.datetime
    _sum: 'LogSumAggregateOutput'
    _avg: 'LogAvgAggregateOutput'
    _min: 'LogMinAggregateOutput'
    _max: 'LogMaxAggregateOutput'
    _count: 'LogCountAggregateOutput'


class LogAvgAggregateOutput(TypedDict, total=False):
    """Log output for aggregating averages"""


class LogSumAggregateOutput(TypedDict, total=False):
    """Log output for aggregating sums"""


class LogScalarAggregateOutput(TypedDict, total=False):
    """Log output including scalar fields"""
    id: _str
    timestamp: datetime.datetime
    level: _str
    message: _str
    component: _str
    createdAt: datetime.datetime


LogMinAggregateOutput = LogScalarAggregateOutput
LogMaxAggregateOutput = LogScalarAggregateOutput


class LogMaxAggregateInput(TypedDict, total=False):
    """Log input for aggregating by max"""
    id: bool
    timestamp: bool
    level: bool
    message: bool
    component: bool
    createdAt: bool


class LogMinAggregateInput(TypedDict, total=False):
    """Log input for aggregating by min"""
    id: bool
    timestamp: bool
    level: bool
    message: bool
    component: bool
    createdAt: bool


class LogNumberAggregateInput(TypedDict, total=False):
    """Log input for aggregating numbers"""


LogAvgAggregateInput = LogNumberAggregateInput
LogSumAggregateInput = LogNumberAggregateInput


LogCountAggregateInput = TypedDict(
    'LogCountAggregateInput',
    {
        'id': bool,
        'timestamp': bool,
        'level': bool,
        'message': bool,
        'component': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

LogCountAggregateOutput = TypedDict(
    'LogCountAggregateOutput',
    {
        'id': int,
        'timestamp': int,
        'level': int,
        'message': int,
        'component': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


LogKeys = Literal[
    'id',
    'timestamp',
    'level',
    'message',
    'component',
    'createdAt',
]
LogScalarFieldKeys = Literal[
    'id',
    'timestamp',
    'level',
    'message',
    'component',
    'createdAt',
]
LogScalarFieldKeysT = TypeVar('LogScalarFieldKeysT', bound=LogScalarFieldKeys)

LogRelationalFieldKeys = _NoneType



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields